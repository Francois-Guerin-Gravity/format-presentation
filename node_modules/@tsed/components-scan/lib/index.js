var path = require('path');
var core = require('@tsed/core');
var di = require('@tsed/di');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return n;
}

function isTsEnv() {
  return require && require.extensions && require.extensions[".ts"] || process.env["TS_TEST"] || process.env.JEST_WORKER_ID !== undefined || process.env.NODE_ENV === "test";
}

const fixPath = require("normalize-path");

function normalizePath(item, ...paths) {
  if (core.isString(item)) {
    const path$1 = path.join(item, ...paths);
    return fixPath(path$1);
  }

  if (core.isArray(item)) {
    return item.map(item => normalizePath(item));
  }

  return item;
}

function mapExcludes(excludes) {
  return excludes.map(s => `!${s.replace(/!/gi, "")}`);
}

function mapExtensions(file) {
  if (!isTsEnv()) {
    file = file.replace(/\.ts$/i, ".js").replace(/{\.ts,\.js}$/i, ".js");
  }

  return file;
}

function cleanGlobPatterns(files, excludes) {
  return [].concat(files).map(s => path.resolve(s)).concat(mapExcludes(excludes)).map(mapExtensions).map(s => normalizePath(s));
}

async function importFiles(patterns, exclude) {
  const {
    default: globby
  } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('globby')); });
  const files = await globby(cleanGlobPatterns(patterns, exclude));
  const symbols = [];

  for (const file of files) {
    if (!file.endsWith(".d.ts")) {
      // prevent .d.ts import if the global pattern isn't correctly configured
      try {
        const exports = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(file)); });
        Object.keys(exports).forEach(key => symbols.push(exports[key]));
      } catch (er) {
        // istanbul ignore next
        console.error(er); // istanbul ignore next

        process.exit(1);
      }
    }
  }

  return symbols;
}

async function resolveSymbols(item, excludes) {
  if (core.isClass(item)) {
    return [item];
  }
  /* istanbul ignore else */


  if (!process.env.WEBPACK) {
    return importFiles(item, excludes);
  }
  /* istanbul ignore next */


  return [];
}

function mapConfiguration(config) {
  if (core.isArray(config)) {
    return config.map(value => {
      return {
        values: [].concat(value)
      };
    });
  }

  return Object.keys(config).reduce((list, key) => {
    list.push({
      endpoint: key,
      values: [].concat(config[key])
    });
    return list;
  }, []);
}
async function importComponents(config, excludes) {
  if (!config) {
    return [];
  }

  config = mapConfiguration(config);
  const promises = [];

  for (const option of config) {
    promises.push(...option.values.map(async value => {
      const symbols = await resolveSymbols(value, excludes);
      return symbols.filter(core.isClass).map(symbol => ({
        token: symbol,
        route: option.endpoint
      }));
    }));
  }

  const result = await Promise.all(promises);
  return result.flat();
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

async function recursiveImports(providers, settings, properties) {
  const {
    exclude = []
  } = settings;
  const promises = providers.map(({
    token
  }) => di.GlobalProviders.get(token)).filter(provider => (provider == null ? void 0 : provider.type) === di.ProviderType.MODULE && provider.configuration).map(provider => importProviders(_extends({
    exclude
  }, provider.configuration), properties));
  return (await Promise.all(promises)).flat();
}
/**
 * Import providers from given patterns.
 *
 * @param settings
 * @param properties
 */


async function importProviders(settings, properties = ["imports"]) {
  const {
    exclude = []
  } = settings;
  const promises = properties.map(key => importComponents(settings[key], exclude));
  const providers = (await Promise.all(promises)).flat();
  const children = await recursiveImports(providers, settings, properties);
  return [...children, ...providers];
}

exports.cleanGlobPatterns = cleanGlobPatterns;
exports.importComponents = importComponents;
exports.importFiles = importFiles;
exports.importProviders = importProviders;
exports.mapConfiguration = mapConfiguration;
exports.normalizePath = normalizePath;
//# sourceMappingURL=index.js.map
