import { join, resolve } from 'path';
import { isString, isArray, isClass } from '@tsed/core';
import { GlobalProviders, ProviderType } from '@tsed/di';

function isTsEnv() {
  return require && require.extensions && require.extensions[".ts"] || process.env["TS_TEST"] || process.env.JEST_WORKER_ID !== undefined || process.env.NODE_ENV === "test";
}

const fixPath = require("normalize-path");

function normalizePath(item, ...paths) {
  if (isString(item)) {
    const path = join(item, ...paths);
    return fixPath(path);
  }

  if (isArray(item)) {
    return item.map(item => normalizePath(item));
  }

  return item;
}

function mapExcludes(excludes) {
  return excludes.map(s => `!${s.replace(/!/gi, "")}`);
}

function mapExtensions(file) {
  if (!isTsEnv()) {
    file = file.replace(/\.ts$/i, ".js").replace(/{\.ts,\.js}$/i, ".js");
  }

  return file;
}

function cleanGlobPatterns(files, excludes) {
  return [].concat(files).map(s => resolve(s)).concat(mapExcludes(excludes)).map(mapExtensions).map(s => normalizePath(s));
}

async function importFiles(patterns, exclude) {
  const {
    default: globby
  } = await import('globby');
  const files = await globby(cleanGlobPatterns(patterns, exclude));
  const symbols = [];

  for (const file of files) {
    if (!file.endsWith(".d.ts")) {
      // prevent .d.ts import if the global pattern isn't correctly configured
      try {
        const exports = await import(file);
        Object.keys(exports).forEach(key => symbols.push(exports[key]));
      } catch (er) {
        // istanbul ignore next
        console.error(er); // istanbul ignore next

        process.exit(1);
      }
    }
  }

  return symbols;
}

async function resolveSymbols(item, excludes) {
  if (isClass(item)) {
    return [item];
  }
  /* istanbul ignore else */


  if (!process.env.WEBPACK) {
    return importFiles(item, excludes);
  }
  /* istanbul ignore next */


  return [];
}

function mapConfiguration(config) {
  if (isArray(config)) {
    return config.map(value => {
      return {
        values: [].concat(value)
      };
    });
  }

  return Object.keys(config).reduce((list, key) => {
    list.push({
      endpoint: key,
      values: [].concat(config[key])
    });
    return list;
  }, []);
}
async function importComponents(config, excludes) {
  if (!config) {
    return [];
  }

  config = mapConfiguration(config);
  const promises = [];

  for (const option of config) {
    promises.push(...option.values.map(async value => {
      const symbols = await resolveSymbols(value, excludes);
      return symbols.filter(isClass).map(symbol => ({
        token: symbol,
        route: option.endpoint
      }));
    }));
  }

  const result = await Promise.all(promises);
  return result.flat();
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

async function recursiveImports(providers, settings, properties) {
  const {
    exclude = []
  } = settings;
  const promises = providers.map(({
    token
  }) => GlobalProviders.get(token)).filter(provider => (provider == null ? void 0 : provider.type) === ProviderType.MODULE && provider.configuration).map(provider => importProviders(_extends({
    exclude
  }, provider.configuration), properties));
  return (await Promise.all(promises)).flat();
}
/**
 * Import providers from given patterns.
 *
 * @param settings
 * @param properties
 */


async function importProviders(settings, properties = ["imports"]) {
  const {
    exclude = []
  } = settings;
  const promises = properties.map(key => importComponents(settings[key], exclude));
  const providers = (await Promise.all(promises)).flat();
  const children = await recursiveImports(providers, settings, properties);
  return [...children, ...providers];
}

export { cleanGlobPatterns, importComponents, importFiles, importProviders, mapConfiguration, normalizePath };
//# sourceMappingURL=index.modern.js.map
