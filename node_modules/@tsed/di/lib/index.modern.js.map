{"version":3,"file":"index.modern.js","sources":["../src/constants/index.ts","../src/domain/ProviderScope.ts","../src/domain/ProviderType.ts","../src/domain/Provider.ts","../src/registries/GlobalProviders.ts","../src/domain/LocalsContainer.ts","../src/domain/Container.ts","../src/domain/InjectablePropertyType.ts","../src/domain/ContextLogger.ts","../src/domain/DIContext.ts","../src/decorators/scope.ts","../src/registries/ProviderRegistry.ts","../src/decorators/injectable.ts","../src/decorators/service.ts","../src/decorators/overrideProvider.ts","../src/decorators/inject.ts","../src/decorators/constant.ts","../src/decorators/value.ts","../src/decorators/intercept.ts","../src/decorators/interceptor.ts","../src/decorators/configuration.ts","../src/decorators/module.ts","../src/decorators/opts.ts","../src/decorators/useOpts.ts","../src/errors/InjectionError.ts","../src/errors/UndefinedTokenError.ts","../src/utils/createContainer.ts","../src/services/DIConfiguration.ts","../src/services/InjectorService.ts","../src/services/DILogger.ts","../src/utils/setLoggerLevel.ts","../src/services/DITest.ts","../src/utils/getConfiguration.ts"],"sourcesContent":["export const INJECTABLE_PROP = \"DI:INJECTABLE_PROP\";\nexport const DI_PARAMS = \"DI:PARAMS\";\nexport const DI_PARAM_OPTIONS = \"DI:PARAM:OPTIONS\";\n","export enum ProviderScope {\n  SINGLETON = \"singleton\",\n  REQUEST = \"request\",\n  INSTANCE = \"instance\"\n}\n","export enum ProviderType {\n  VALUE = \"value\",\n  FACTORY = \"factory\",\n  SERVICE = \"service\",\n  PROVIDER = \"provider\",\n  MODULE = \"module\",\n  CONTROLLER = \"controller\",\n  INTERCEPTOR = \"interceptor\",\n  MIDDLEWARE = \"middleware\"\n}\n","import {classOf, getClassOrSymbol, isClass, nameOf, Store, Type} from \"@tsed/core\";\nimport {IProvider, TokenProvider} from \"../interfaces\";\nimport {ProviderScope} from \"./ProviderScope\";\nimport {ProviderType} from \"./ProviderType\";\n\nexport class Provider<T = any> implements IProvider<T> {\n  public type: ProviderType | any = ProviderType.PROVIDER;\n  public instance: T;\n  public deps: TokenProvider[];\n  public imports: any[];\n  public useFactory: Function;\n  public useAsyncFactory: Function;\n  public useValue: any;\n  // FIXME issue with #useClass\n  _useClass: Type<T>;\n  #provide: TokenProvider;\n  #store: Store;\n  #tokenStore: Store;\n\n  [key: string]: any;\n\n  constructor(token: TokenProvider, options: Partial<Provider> = {}) {\n    this.provide = token;\n    this.useClass = token;\n\n    Object.assign(this, options);\n  }\n\n  get token() {\n    return this.#provide;\n  }\n\n  get provide(): TokenProvider {\n    return this.#provide;\n  }\n\n  set provide(value: TokenProvider) {\n    if (value) {\n      this.#provide = getClassOrSymbol(value);\n      this.#tokenStore = this.#store = Store.from(value);\n    }\n  }\n\n  get useClass(): Type<T> {\n    return this._useClass;\n  }\n\n  /**\n   * Create a new store if the given value is a class. Otherwise the value is ignored.\n   * @param value\n   */\n  set useClass(value: Type<T>) {\n    if (isClass(value)) {\n      this._useClass = classOf(value);\n      this.#store = Store.from(value);\n    }\n  }\n\n  get className() {\n    return this.name;\n  }\n\n  get name() {\n    return nameOf(this.provide);\n  }\n\n  public get store(): Store {\n    return this.#store;\n  }\n\n  /**\n   * Get the scope of the provider.\n   *\n   * ::: tip Note\n   * Async provider is always a SINGLETON\n   * :::\n   *\n   * @returns {boolean}\n   */\n  get scope(): ProviderScope {\n    if (this.isAsync()) {\n      return ProviderScope.SINGLETON;\n    }\n\n    return this.get(\"scope\");\n  }\n\n  /**\n   * Change the scope value of the provider.\n   * @param scope\n   */\n  set scope(scope: ProviderScope) {\n    this.store.set(\"scope\", scope);\n  }\n\n  get configuration(): Partial<TsED.Configuration> {\n    return this.get(\"configuration\");\n  }\n\n  set configuration(configuration: Partial<TsED.Configuration>) {\n    this.store.set(\"configuration\", configuration);\n  }\n\n  get(key: string) {\n    return this.store.get(key) || this.#tokenStore.get(key);\n  }\n\n  isAsync(): boolean {\n    return !!this.useAsyncFactory;\n  }\n\n  clone(): Provider {\n    return new (classOf(this))(this.#provide, this);\n  }\n\n  toString() {\n    return [\n      \"Token\",\n      this.name,\n      this.useClass && nameOf(this.useClass),\n      this.useFactory && \"Factory\",\n      this.useValue && \"Value\",\n      this.useAsyncFactory && \"AsyncFactory\"\n    ]\n      .filter(Boolean)\n      .join(\":\");\n  }\n}\n","import {getClassOrSymbol, Type} from \"@tsed/core\";\nimport {Provider} from \"../domain/Provider\";\nimport {ProviderType} from \"../domain/ProviderType\";\nimport {InvokeOptions} from \"../interfaces\";\nimport type {IProvider, RegistrySettings, TokenProvider} from \"../interfaces\";\n\nexport class GlobalProviderRegistry extends Map<TokenProvider, Provider> {\n  #settings: Map<string, RegistrySettings> = new Map();\n\n  /**\n   * The get() method returns a specified element from a Map object.\n   * @param key Required. The key of the element to return from the Map object.\n   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.\n   */\n  get(key: TokenProvider): Provider | undefined {\n    return super.get(getClassOrSymbol(key));\n  }\n\n  /**\n   * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key\n   * @returns {boolean}\n   */\n  has(key: TokenProvider): boolean {\n    return super.has(getClassOrSymbol(key));\n  }\n\n  /**\n   * The set() method adds or updates an element with a specified key and value to a Map object.\n   * @param key Required. The key of the element to add to the Map object.\n   * @param metadata Required. The value of the element to add to the Map object.\n   */\n  set(key: TokenProvider, metadata: Provider): this {\n    super.set(getClassOrSymbol(key), metadata);\n\n    return this;\n  }\n\n  /**\n   *\n   * @param target\n   * @param options\n   */\n  merge(target: TokenProvider, options: Partial<IProvider>): void {\n    const meta = this.createIfNotExists(target, options);\n\n    Object.keys(options).forEach((key) => {\n      meta[key] = (options as any)[key];\n    });\n\n    this.set(target, meta);\n  }\n\n  /**\n   * The delete() method removes the specified element from a Map object.\n   * @param key Required. The key of the element to remove from the Map object.\n   * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.\n   */\n  delete(key: TokenProvider): boolean {\n    return super.delete(getClassOrSymbol(key));\n  }\n\n  createRegistry(type: string, model: Type<Provider>, options: Partial<RegistrySettings> = {}) {\n    const defaultOptions = this.getRegistrySettings(type);\n\n    options = Object.assign(defaultOptions, {\n      ...options,\n      model\n    });\n\n    this.#settings.set(type, options);\n\n    return this;\n  }\n\n  onInvoke(provider: Provider, locals: Map<TokenProvider, any>, deps: any[]) {\n    const settings = this.#settings.get(provider.type);\n\n    if (settings?.onInvoke) {\n      settings.onInvoke(provider, locals, deps);\n    }\n  }\n\n  getRegistrySettings(target: string | TokenProvider): RegistrySettings {\n    let type: string = \"provider\";\n\n    if (typeof target === \"string\") {\n      type = target;\n    } else {\n      const provider = this.get(target);\n      if (provider) {\n        type = provider.type;\n      }\n    }\n\n    return (\n      this.#settings.get(type) || {\n        model: Provider\n      }\n    );\n  }\n\n  createRegisterFn(type: string) {\n    return (provider: any | IProvider, instance?: any): void => {\n      // istanbul ignore next\n      if (!provider.provide) {\n        provider = {\n          provide: provider\n        };\n      }\n\n      provider = Object.assign({instance}, provider, {type});\n      this.merge(provider.provide, provider);\n    };\n  }\n\n  /**\n   *\n   * @param key\n   * @param options\n   */\n  protected createIfNotExists(key: TokenProvider, options: Partial<IProvider>): Provider {\n    const type = options.type || ProviderType.PROVIDER;\n\n    if (!this.has(key)) {\n      const {model = Provider} = this.#settings.get(type) || {};\n\n      const item = new model(key);\n\n      this.set(key, item);\n    }\n\n    return this.get(key)!;\n  }\n}\n\n/**\n *\n * @type {GlobalProviders}\n */\n// tslint:disable-next-line: variable-name\nexport const GlobalProviders = new GlobalProviderRegistry();\n","import type {TokenProvider} from \"../interfaces/TokenProvider\";\n\nexport class LocalsContainer<V = any> extends Map<TokenProvider, V> {\n  /**\n   * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).\n   * @param eventName The event name to emit at all services.\n   * @param args List of the parameters to give to each services.\n   * @returns {Promise<any[]>} A list of promises.\n   */\n  public async emit(eventName: string, ...args: any[]) {\n    for (const handler of this.getListeners(eventName)) {\n      await handler(...args);\n    }\n  }\n\n  /**\n   * @param eventName\n   * @param value\n   * @param args\n   */\n  public alter<T = any>(eventName: string, value: any, ...args: any[]): T {\n    for (const handler of this.getListeners(eventName)) {\n      value = handler(value, ...args);\n    }\n\n    return value;\n  }\n\n  /**\n   * @param eventName\n   * @param value\n   * @param args\n   */\n  public async alterAsync<T = any>(eventName: string, value: any, ...args: any[]): Promise<T> {\n    for (const handler of this.getListeners(eventName)) {\n      value = handler(value, ...args);\n    }\n\n    return value;\n  }\n\n  toArray() {\n    return [...this.values()];\n  }\n\n  async destroy() {\n    await this.emit(\"$onDestroy\");\n    this.clear();\n  }\n\n  protected getListeners(event: string): any[] {\n    return this.toArray().reduce((listeners, instance) => {\n      if (typeof instance === \"object\" && instance && event in instance) {\n        return listeners.concat((instance as any)[event].bind(instance));\n      }\n\n      return listeners;\n    }, []);\n  }\n}\n","import type {IProvider} from \"../interfaces/IProvider\";\nimport type {ProviderType} from \"./ProviderType\";\nimport type {TokenProvider} from \"../interfaces/TokenProvider\";\nimport {GlobalProviders} from \"../registries/GlobalProviders\";\nimport {LocalsContainer} from \"./LocalsContainer\";\nimport {Provider} from \"./Provider\";\n\nexport class Container extends LocalsContainer<Provider> {\n  /**\n   *\n   * @param token\n   * @param settings\n   */\n  public add(token: TokenProvider, settings: Partial<IProvider> = {}): this {\n    const provider = GlobalProviders.has(token) ? GlobalProviders.get(token)!.clone() : new Provider(token);\n\n    Object.assign(provider, settings);\n\n    return super.set(token, provider);\n  }\n\n  /**\n   * Add a provider to the\n   * @param token\n   * @param settings\n   */\n  public addProvider(token: TokenProvider, settings: Partial<IProvider> = {}): this {\n    return this.add(token, settings);\n  }\n\n  /**\n   *\n   * @param token\n   */\n  public hasProvider(token: TokenProvider) {\n    return super.has(token);\n  }\n\n  /**\n   * Add a provider to the\n   * @param token\n   * @param provider\n   */\n  public setProvider(token: TokenProvider, provider: Provider) {\n    return super.set(token, provider);\n  }\n\n  /**\n   * The getProvider() method returns a specified element from a Map object.\n   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.\n   * @param token\n   */\n  public getProvider(token: TokenProvider): Provider | undefined {\n    return super.get(token);\n  }\n\n  /**\n   * Get all providers registered in the injector container.\n   *\n   * @param {ProviderType} type Filter the list by the given ProviderType.\n   * @returns {[TokenProvider , Provider<any>][]}\n   */\n  public getProviders(type?: ProviderType | string): Provider[] {\n    return Array.from(this)\n      .filter(([_, provider]) => (type ? provider.type === type : true))\n      .map(([_, provider]) => provider);\n  }\n\n  public addProviders(container: Map<TokenProvider, Provider>) {\n    container.forEach((provider) => {\n      if (!this.hasProvider(provider.provide)) {\n        this.setProvider(provider.provide, provider.clone());\n      }\n    });\n  }\n}\n","export enum InjectablePropertyType {\n  METHOD = \"method\",\n  PROPERTY = \"property\",\n  CONSTANT = \"constant\",\n  VALUE = \"value\",\n  INTERCEPTOR = \"interceptor\"\n}\n","import {levels, LogLevel} from \"@tsed/logger\";\n\nexport interface ContextLoggerOptions extends Record<string, any> {\n  id: string;\n  url?: string;\n  dateStart?: Date;\n  level?: \"debug\" | \"info\" | \"warn\" | \"error\" | \"off\" | \"all\";\n  maxStackSize?: number;\n  minimalRequestPicker?: (o: any) => any;\n  completeRequestPicker?: (o: any) => any;\n  ignoreLog?: (data: any) => boolean;\n  additionalProps?: Record<any, any>;\n}\n\nexport class ContextLogger {\n  id: string;\n  url: string;\n  minimalRequestPicker: Function;\n  completeRequestPicker: Function;\n  maxStackSize: number;\n  readonly #additionalProps: Record<string, unknown>;\n  readonly #dateStart: Date;\n  readonly #ignoreLog: (data: any) => boolean;\n  #stack: any = [];\n  #level: LogLevel;\n\n  constructor(\n    private logger: any,\n    {\n      id,\n      url = \"\",\n      dateStart = new Date(),\n      ignoreUrlPatterns = [],\n      minimalRequestPicker,\n      completeRequestPicker,\n      level = \"all\",\n      maxStackSize = 30,\n      ignoreLog,\n      additionalProps\n    }: ContextLoggerOptions\n  ) {\n    this.id = id;\n    this.url = url;\n    this.#additionalProps = additionalProps || {};\n    this.#dateStart = dateStart;\n    this.#ignoreLog = ignoreLog || (() => false);\n    this.minimalRequestPicker = minimalRequestPicker || ((l: any) => l);\n    this.completeRequestPicker = completeRequestPicker || ((l: any) => l);\n    // @ts-ignore\n    this.#level = levels()[level.toUpperCase()] || levels().ALL;\n    this.maxStackSize = maxStackSize;\n  }\n\n  info(obj: any) {\n    this.run(levels().INFO, obj, (obj) => this.minimalRequestPicker(this.getData(obj)));\n    return this;\n  }\n\n  debug(obj: any, withRequest: boolean = true) {\n    this.run(levels().DEBUG, obj, (obj) => {\n      obj = this.getData(obj);\n      return withRequest ? this.completeRequestPicker(obj) : obj;\n    });\n    return this;\n  }\n\n  warn(obj: any) {\n    this.run(levels().WARN, obj, (obj) => this.completeRequestPicker(this.getData(obj)));\n    return this;\n  }\n\n  error(obj: any) {\n    this.run(levels().ERROR, obj, (obj) => this.completeRequestPicker(this.getData(obj)));\n    return this;\n  }\n\n  trace(obj: any) {\n    this.run(levels().TRACE, obj, (obj) => this.completeRequestPicker(this.getData(obj)));\n    return this;\n  }\n\n  public flush() {\n    if (this.#stack.length) {\n      this.#stack.forEach(({level, data}: any) => {\n        this.logger[level](data);\n      });\n\n      this.#stack = [];\n    }\n  }\n\n  public isLevelEnabled(otherLevel: string | LogLevel) {\n    return this.#level.isLessThanOrEqualTo(otherLevel);\n  }\n\n  destroy() {\n    this.flush();\n\n    this.logger = undefined;\n    this.#stack = undefined;\n  }\n\n  /**\n   * Return the duration between the time when LogIncomingRequest has handle the request and now.\n   * @returns {number}\n   */\n  protected getDuration(): number {\n    return new Date().getTime() - this.#dateStart.getTime();\n  }\n\n  protected getData(obj: any) {\n    if (typeof obj === \"string\") {\n      obj = {message: obj};\n    }\n\n    return {...this.#additionalProps, reqId: this.id, time: new Date(), duration: this.getDuration(), ...obj};\n  }\n\n  protected run(level: LogLevel, obj: any, mapper: (data: any) => any) {\n    if (!this.isLevelEnabled(level)) {\n      return;\n    }\n\n    if (!this.#ignoreLog(obj)) {\n      this.#stack.push({level: level.levelStr.toLowerCase(), data: mapper(obj)});\n    }\n\n    if (this.maxStackSize < this.#stack.length) {\n      this.flush();\n    }\n  }\n}\n","import type {Env} from \"@tsed/core\";\nimport {InjectorService} from \"../services/InjectorService\";\nimport {ContextLogger, ContextLoggerOptions} from \"./ContextLogger\";\nimport {LocalsContainer} from \"./LocalsContainer\";\n\nexport interface ContextMethods extends Map<any, any> {\n  readonly id: string;\n  readonly logger: ContextLogger;\n  readonly injector: InjectorService;\n  readonly container: LocalsContainer;\n  readonly env: Env;\n\n  destroy(): any;\n}\n\ndeclare global {\n  namespace TsED {\n    interface Context {}\n  }\n}\n\nexport interface DIContextOptions extends Omit<ContextLoggerOptions, \"dateStart\"> {\n  id: string;\n  logger: any;\n  injector?: InjectorService;\n}\n\nexport class DIContext extends Map<any, any> implements ContextMethods {\n  [x: string]: any;\n\n  /**\n   * Request id generated by @@contextMiddleware@@.\n   *\n   * ::: tip\n   * By default Ts.ED generate uuid like that `uuidv4().replace(/-/gi, \"\"))`.\n   * Dash are removed to simplify tracking logs in Kibana\n   * :::\n   *\n   * ::: tip\n   * Request id can by customized by changing the server configuration.\n   *\n   * ```typescript\n   * @Configuration({\n   *   logger: {\n   *     reqIdBuilder: createUniqId // give your own id generator function\n   *   }\n   * })\n   * class Server {\n   *\n   * }\n   * ```\n   * :::\n   *\n   */\n  readonly id: string;\n  /**\n   * Date when request have been handled by the server. @@RequestLogger@@ use this date to log request duration.\n   */\n  readonly dateStart: Date = new Date();\n  /**\n   * Logger attached to the context request.\n   */\n  public logger: ContextLogger;\n\n  #container = new LocalsContainer<any>();\n\n  readonly #injector: InjectorService;\n\n  constructor({id, injector, logger, ignoreLog, ...options}: DIContextOptions) {\n    super();\n    this.id = id;\n\n    injector && (this.#injector = injector);\n\n    this.logger = new ContextLogger(logger, {\n      ...options,\n      dateStart: this.dateStart,\n      id,\n      ignoreLog\n    });\n  }\n\n  /**\n   * The request container used by the Ts.ED DI. It contain all services annotated with `@Scope(ProviderScope.REQUEST)`\n   */\n  get container(): LocalsContainer {\n    return this.#container;\n  }\n\n  /**\n   *\n   */\n  get injector(): InjectorService {\n    return this.#injector;\n  }\n\n  get env() {\n    return this.injector.settings.env;\n  }\n\n  async destroy() {\n    await this.container.destroy();\n    this.logger.destroy();\n    // @ts-ignore\n    delete this.logger;\n  }\n\n  async emit(eventName: string, ...args: any[]) {\n    return this.injector?.emit(eventName, ...args);\n  }\n}\n\nexport type BaseContext = DIContext & TsED.Context;\n","import {StoreSet} from \"@tsed/core\";\nimport {ProviderScope} from \"../domain/ProviderScope\";\n\n/**\n *\n * @param {\"request\" | \"singleton\" | ProviderScope} scope\n * @returns {Function}\n * @constructor\n */\nexport function Scope(scope: \"request\" | \"singleton\" | ProviderScope = ProviderScope.REQUEST) {\n  return StoreSet(\"scope\", scope);\n}\n","import {Provider} from \"../domain/Provider\";\nimport type {IProvider} from \"../interfaces\";\nimport {ProviderScope, ProviderType} from \"../domain\";\nimport {GlobalProviders} from \"./GlobalProviders\";\n\n/**\n *\n */\nGlobalProviders.createRegistry(ProviderType.CONTROLLER, Provider);\n\n/**\n * Register a provider configuration.\n * @param {IProvider<any>} provider\n */\nexport function registerProvider(provider: Partial<IProvider>): void {\n  if (!provider.provide) {\n    throw new Error(\"Provider.provide is required\");\n  }\n\n  GlobalProviders.merge(provider.provide, provider);\n}\n\n/**\n * Add a new factory in the `ProviderRegistry`.\n *\n * #### Example with symbol definition\n *\n *\n * ```typescript\n * import {registerFactory, InjectorService} from \"@tsed/di\";\n *\n * export interface IMyFooFactory {\n *    getFoo(): string;\n * }\n *\n * export type MyFooFactory = IMyFooFactory;\n * export const MyFooFactory = Symbol(\"MyFooFactory\");\n *\n * registerFactory(MyFooFactory, {\n *      getFoo:  () => \"test\"\n * });\n *\n * // or\n *\n * registerFactory({provide: MyFooFactory, instance: {\n *      getFoo:  () => \"test\"\n * }});\n *\n * @Service()\n * export class OtherService {\n *      constructor(@Inject(MyFooFactory) myFooFactory: MyFooFactory){\n *          console.log(myFooFactory.getFoo()); /// \"test\"\n *      }\n * }\n * ```\n *\n * > Note: When you use the factory method with Symbol definition, you must use the `@Inject()`\n * decorator to retrieve your factory in another Service. Advice: By convention all factory class name will be prefixed by\n * `Factory`.\n *\n * #### Example with class\n *\n * ```typescript\n * import {InjectorService, registerFactory} from \"@tsed/di\";\n *\n * export class MyFooService {\n *  constructor(){}\n *      getFoo() {\n *          return \"test\";\n *      }\n * }\n *\n * registerFactory(MyFooService, new MyFooService());\n * // or\n * registerFactory({provider: MyFooService, instance: new MyFooService()});\n *\n * @Service()\n * export class OtherService {\n *      constructor(myFooService: MyFooService){\n *          console.log(myFooFactory.getFoo()); /// \"test\"\n *      }\n * }\n * ```\n * @deprecated Since 2021-05-15. Use registerProvider instead.\n */\nexport const registerFactory = registerProvider;\n\n/**\n * Add a new value in the `ProviderRegistry`.\n *\n * #### Example with symbol definition\n *\n *\n * ```typescript\n * import {registerValue, InjectorService} from \"@tsed/di\";\n *\n * const MyValue = Symbol.from(\"MyValue\")\n *\n * registerValue({token: MyValue, useValue: \"myValue\"});\n *\n * @Service()\n * export class OtherService {\n *      constructor(@Inject(MyValue) myValue: string){\n *          console.log(myValue); /// \"myValue\"\n *      }\n * }\n * ```\n */\nexport const registerValue = (provider: any | IProvider<any>, value?: any): void => {\n  if (!provider.provide) {\n    provider = {\n      provide: provider\n    };\n  }\n\n  provider = Object.assign(\n    {\n      scope: ProviderScope.SINGLETON,\n      useValue: value\n    },\n    provider,\n    {type: ProviderType.VALUE}\n  );\n  GlobalProviders.merge(provider.provide, provider);\n};\n\n/**\n * Add a new controller in the `ProviderRegistry`. This controller will be built when `InjectorService` will be loaded.\n *\n * #### Example\n *\n * ```typescript\n * import {registerController, InjectorService} from \"@tsed/di\";\n *\n * export default class MyController {\n *     constructor(){}\n *     transform() {\n *         return \"test\";\n *     }\n * }\n *\n * registerController({provide: MyController});\n * // or\n * registerController(MyController);\n *\n * const injector = new InjectorService();\n * injector.load();\n *\n * const myController = injector.get<MyController>(MyController);\n * myController.getFoo(); // test\n * ```\n *\n * @param provider Provider configuration.\n */\nexport const registerController = GlobalProviders.createRegisterFn(ProviderType.CONTROLLER);\n","import type {IProvider} from \"../interfaces\";\nimport {registerProvider} from \"../registries/ProviderRegistry\";\n\n/**\n * The decorators `@Injectable()` declare a new service can be injected in other service, controller, interceptor, etc.. on there `constructor`.\n * All classes annotated with `@Injectable()` are built one time, excepted if you change the default provider configuration.\n *\n * <<< @/docs/snippets/providers/getting-started-injectable.ts\n *\n * ::: tip\n * `@Injectable()` use the `reflect-metadata` to collect and inject the built provided to other services.\n * :::\n *\n * ### Options\n *\n * - type (@@ProviderType@@  or `string`): Kind of provider. (Default: `ProviderType.PROVIDER`)\n * - scope (@@ProviderScope@): Kind of provider. (Default: `ProviderScope.SINGLETON`)\n * - deps (`Type<any>`): List of class or provider which will be injected to the constructor (Note: This options override default metadata generated by Typescript).\n *\n * @returns {Function}\n * @decorator\n */\nexport function Injectable(options: Partial<IProvider> = {}): ClassDecorator {\n  return (provide: any) => {\n    registerProvider({\n      ...options,\n      provide\n    });\n  };\n}\n","import {Injectable} from \"./injectable\";\n\n/**\n * The decorators `@Service()` declare a new service can be injected in other service or controller on there `constructor`.\n * All services annotated with `@Service()` are constructed one time.\n *\n * > `@Service()` use the `reflect-metadata` to collect and inject service on controllers or other services.\n *\n * @returns {Function}\n * @decorator\n */\nexport function Service(): Function {\n  return Injectable();\n}\n","import {Type} from \"@tsed/core\";\nimport {GlobalProviders} from \"../registries/GlobalProviders\";\n\n/**\n * Override a provider which is already registered in ProviderRegistry.\n * @returns {Function}\n * @decorators\n * @param originalProvider\n */\nexport function OverrideProvider(originalProvider: Type<any>): Function {\n  return (target: Type<any>): void => {\n    GlobalProviders.get(originalProvider)!.useClass = target;\n  };\n}\n","import {decoratorTypeOf, DecoratorTypes, Metadata, Store, UnsupportedDecoratorType} from \"@tsed/core\";\nimport {INJECTABLE_PROP} from \"../constants\";\n\n/**\n * Inject a provider to another provider.\n *\n * Use this decorator to inject a custom provider on constructor parameter or property.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @Inject(CONNECTION)\n *   connection: CONNECTION;\n * }\n * ```\n *\n * @param symbol\n * @param onGet Use the given name method to inject\n * @returns {Function}\n * @decorator\n */\nexport function Inject(symbol?: any, onGet?: (bean: any) => any): Function {\n  return (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<Function> | number): any | void => {\n    const bindingType = decoratorTypeOf([target, propertyKey, descriptor]);\n\n    switch (bindingType) {\n      case DecoratorTypes.PARAM:\n      case DecoratorTypes.PARAM_CTOR:\n        if (symbol) {\n          const paramTypes = Metadata.getParamTypes(target, propertyKey);\n\n          paramTypes[descriptor as number] = symbol;\n          Metadata.setParamTypes(target, propertyKey, paramTypes);\n        }\n        break;\n\n      case DecoratorTypes.PROP:\n        Store.from(target).merge(INJECTABLE_PROP, {\n          [propertyKey]: {\n            bindingType,\n            propertyKey,\n            onGet,\n            useType: symbol || Metadata.getType(target, propertyKey)\n          }\n        });\n        break;\n\n      case DecoratorTypes.METHOD:\n        Store.from(target).merge(INJECTABLE_PROP, {\n          [propertyKey]: {\n            bindingType,\n            propertyKey\n          }\n        });\n\n        return descriptor;\n\n      default:\n        throw new UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);\n    }\n  };\n}\n","import {Store} from \"@tsed/core\";\nimport {INJECTABLE_PROP} from \"../constants\";\nimport type {InjectableProperties} from \"../interfaces\";\nimport {InjectablePropertyType} from \"../domain/InjectablePropertyType\";\n\n/**\n * Return value from Configuration.\n *\n * ## Example\n *\n * ```typescript\n * import {Env} from \"@tsed/core\";\n * import {Constant, Value} from \"@tsed/di\";\n *\n * export class MyClass {\n *\n *    @Constant(\"env\")\n *    env: Env;\n *\n *    @Value(\"swagger.path\")\n *    swaggerPath: string;\n *\n *    @Value(\"swagger.path\", \"defaultValue\")\n *    swaggerPath: string;\n *\n *    constructor() {\n *       console.log(this.swaggerPath) // undefined. Not available on constructor\n *    }\n *\n *    $onInit() {\n *      console.log(this.swaggerPath)  // something\n *    }\n * }\n * ```\n *\n * @param {string} expression\n * @param defaultValue\n * @returns {(targetClass: any, attributeName: string) => any}\n * @decorator\n */\nexport function Constant(expression: string, defaultValue?: any): any {\n  return (target: any, propertyKey: string) => {\n    Store.from(target).merge(INJECTABLE_PROP, {\n      [propertyKey]: {\n        bindingType: InjectablePropertyType.CONSTANT,\n        propertyKey,\n        expression,\n        defaultValue\n      }\n    } as InjectableProperties);\n  };\n}\n","import {Store} from \"@tsed/core\";\nimport {INJECTABLE_PROP} from \"../constants\";\nimport type {InjectableProperties} from \"../interfaces/InjectableProperties\";\nimport {InjectablePropertyType} from \"../domain/InjectablePropertyType\";\n\n/**\n * Return value from Configuration.\n *\n * ## Example\n *\n * ```typescript\n * import {Env} from \"@tsed/core\";\n * import {Constant, Value} from \"@tsed/di\";\n *\n * export class MyClass {\n *\n *    @Constant(\"env\")\n *    env: Env;\n *\n *    @Value(\"swagger.path\")\n *    swaggerPath: string;\n *\n *    @Value(\"swagger.path\", \"defaultValue\")\n *    swaggerPath: string;\n *\n *    constructor() {\n *       console.log(this.swaggerPath) // undefined. Not available on constructor\n *    }\n *\n *    $onInit() {\n *      console.log(this.swaggerPath)  // something\n *    }\n * }\n * ```\n *\n * @param expression\n * @param defaultValue\n * @returns {(targetClass: any, attributeName: string) => any}\n * @decorator\n */\nexport function Value(expression: any, defaultValue?: any) {\n  return (target: any, propertyKey: string) => {\n    Store.from(target).merge(INJECTABLE_PROP, {\n      [propertyKey]: {\n        bindingType: InjectablePropertyType.VALUE,\n        propertyKey,\n        expression,\n        defaultValue\n      }\n    } as InjectableProperties);\n  };\n}\n","import {Store, Type} from \"@tsed/core\";\nimport {INJECTABLE_PROP} from \"../constants\";\nimport type {InjectableProperties, InterceptorMethods} from \"../interfaces\";\nimport {InjectablePropertyType} from \"../domain\";\n\n/**\n * Attaches interceptor to method call and executes the before and after methods\n *\n * @param interceptor\n * @param options\n * @decorator\n */\nexport function Intercept<T extends InterceptorMethods>(interceptor: Type<T>, options?: any): MethodDecorator {\n  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {\n    Store.from(target).merge(INJECTABLE_PROP, {\n      [propertyKey]: {\n        bindingType: InjectablePropertyType.INTERCEPTOR,\n        propertyKey,\n        useType: interceptor,\n        options\n      }\n    } as InjectableProperties);\n\n    return descriptor;\n  };\n}\n","import {ProviderType} from \"../domain/ProviderType\";\nimport {Injectable} from \"./injectable\";\n\n/**\n * The decorators `@Service()` declare a new service can be injected in other service or controller on there `constructor`.\n * All services annotated with `@Service()` are constructed one time.\n *\n * > `@Service()` use the `reflect-metadata` to collect and inject service on controllers or other services.\n *\n * @returns {Function}\n * @decorator\n */\nexport function Interceptor(): Function {\n  return Injectable({\n    type: ProviderType.INTERCEPTOR\n  });\n}\n","import {DecoratorParameters, decoratorTypeOf, DecoratorTypes, StoreSet} from \"@tsed/core\";\nimport {Inject} from \"../decorators/inject\";\nimport {DIConfiguration} from \"../services/DIConfiguration\";\n\n/**\n * Get or set Configuration on a class.\n *\n * @decorator\n */\nexport function Configuration(configuration: Partial<TsED.Configuration> = {}): Function {\n  return (...args: DecoratorParameters) => {\n    switch (decoratorTypeOf(args)) {\n      case DecoratorTypes.CLASS:\n        StoreSet(\"configuration\", configuration)(args[0]);\n\n        break;\n      default:\n      case DecoratorTypes.PARAM_CTOR:\n        return Inject(Configuration)(args[0], args[1], args[2] as number);\n    }\n  };\n}\n\nexport type Configuration = TsED.Configuration & DIConfiguration;\n","import {useDecorators} from \"@tsed/core\";\nimport {ProviderScope, ProviderType} from \"../domain\";\nimport type {DIResolver, TokenProvider} from \"../interfaces\";\nimport {Configuration} from \"./configuration\";\nimport {Injectable} from \"./injectable\";\n\nexport interface ModuleOptions extends Omit<TsED.Configuration, \"scopes\"> {\n  /**\n   * Provider scope\n   */\n  scope?: ProviderScope;\n  /**\n   * Providers must be initialized before building this module\n   */\n  imports?: TokenProvider[];\n  /**\n   * Explicit token must be injected in the constructor\n   */\n  deps?: TokenProvider[];\n  /**\n   * A list of resolvers to inject provider from external DI.\n   */\n  resolvers?: DIResolver[];\n\n  /**\n   * Additional properties are stored as provider configuration.\n   */\n  [key: string]: any;\n}\n\n/**\n * Declare a new Ts.ED module\n *\n * ## Options\n * - imports: List of Provider which must be built by injector before invoking the module\n * - resolvers: List of external DI must be used to resolve unknown provider\n * - deps: List of provider must be injected to the module constructor (explicit declaration)\n *\n * @param options\n * @decorator\n */\nexport function Module(options: Partial<ModuleOptions> = {}) {\n  const {scopes, imports, resolvers, deps, scope, ...configuration} = options;\n\n  return useDecorators(\n    Configuration(configuration),\n    Injectable({\n      type: ProviderType.MODULE,\n      scope: ProviderScope.SINGLETON,\n      imports,\n      deps,\n      injectable: false,\n      resolvers\n    })\n  );\n}\n","import {classOf} from \"@tsed/core\";\nimport {DI_PARAM_OPTIONS} from \"../constants\";\nimport {ProviderScope} from \"../domain/ProviderScope\";\nimport {Inject} from \"./inject\";\nimport {Scope} from \"./scope\";\n\n/**\n * Get instance options. This options depending on his invocation context.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @param target\n * @param propertyKey\n * @param index\n * @decorator\n */\nexport function Opts(target: any, propertyKey: string | symbol, index: number) {\n  Scope(ProviderScope.INSTANCE)(classOf(target));\n  Inject(DI_PARAM_OPTIONS)(target, propertyKey, index);\n}\n","import {decoratorTypeOf, DecoratorTypes, Store, UnsupportedDecoratorType} from \"@tsed/core\";\nimport {DI_PARAM_OPTIONS, INJECTABLE_PROP} from \"../constants\";\n\n/**\n * Add options to invoke the Service.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @returns {Function}\n * @decorator\n * @param options\n */\nexport function UseOpts(options: {[key: string]: any}): Function {\n  return (target: Object, propertyKey: string | symbol, index?: number): any => {\n    const bindingType = decoratorTypeOf([target, propertyKey, index]);\n\n    switch (bindingType) {\n      case DecoratorTypes.PARAM_CTOR:\n        Store.from(target).merge(`${DI_PARAM_OPTIONS}:${index}`, options);\n        break;\n\n      case DecoratorTypes.PROP:\n        Store.from(target).merge(INJECTABLE_PROP, {\n          [propertyKey as string]: {\n            options\n          }\n        });\n        break;\n\n      default:\n        throw new UnsupportedDecoratorType(UseOpts, [target, propertyKey, index]);\n    }\n  };\n}\n","import {getConstructorArgNames, isClass, isString, nameOf} from \"@tsed/core\";\nimport chalk from \"chalk\";\nimport {TokenProvider} from \"../interfaces\";\n\nexport class InjectionError extends Error {\n  name = \"INJECTION_ERROR\";\n\n  public tokens: TokenProvider[] = [];\n  public origin: any;\n\n  constructor(token: TokenProvider, origin?: any) {\n    super(isString(origin) ? origin : \"\");\n\n    this.tokens = [token];\n\n    if (origin) {\n      if (isString(origin)) {\n        this.origin = {\n          message: origin,\n          stack: this.stack\n        };\n      } else {\n        if (origin.tokens) {\n          this.tokens = this.tokens.concat(origin.tokens);\n          this.origin = origin.origin;\n        } else {\n          this.origin = origin;\n          this.stack = origin.stack;\n        }\n      }\n    }\n\n    const originMessage = this.origin ? \"\\nOrigin: \" + this.origin.message : \"\";\n    const tokensMessage = this.tokens.map((token) => nameOf(token)).join(\" > \");\n\n    this.message = `Injection failed on ${tokensMessage}${originMessage}`;\n  }\n\n  static throwInjectorError(token: any, currentDependency: any, error: any) {\n    if (currentDependency && isClass(token)) {\n      error.message = printDependencyInjectionError(token, {...currentDependency, message: error.message});\n    }\n\n    throw new InjectionError(token, error);\n  }\n}\n\nfunction printDependencyInjectionError(token: any, options: {token: any; index: number; deps: any[]; message: string}) {\n  let erroredArg = \"\";\n\n  const args = getConstructorArgNames(token)\n    .map((arg, index) => {\n      if (options.index === index) {\n        erroredArg = arg;\n        arg = chalk.red(arg);\n      }\n\n      return `${arg}: ${nameOf(options.deps[index])}`;\n    })\n    .join(\", \");\n\n  const signature = nameOf(token) + \"->constructor(\" + args + \")\";\n  const indexOf = signature.indexOf(erroredArg) - 5;\n  const drawline = (indexOf: number) => \" \".repeat(indexOf) + chalk.red(\"^\" + \"â€¾\".repeat(erroredArg.length - 1));\n\n  return \"Unable to inject dependency. \" + options.message + \"\\n\\n\" + signature + \"\\n\" + (indexOf > -1 ? drawline(indexOf) : \"\");\n}\n","export class UndefinedTokenError extends Error {\n  name = \"UNDEFINED_TOKEN_ERROR\";\n\n  constructor() {\n    super(\n      \"Given token is undefined. Have you enabled emitDecoratorMetadata in your tsconfig.json or decorated your class with @Injectable, @Service, ... decorator ?\"\n    );\n  }\n}\n","import {Type} from \"@tsed/core\";\nimport {Container} from \"../domain/Container\";\nimport {GlobalProviders} from \"../registries/GlobalProviders\";\n\nexport function createContainer(rootModule?: Type<any>) {\n  const container = new Container(GlobalProviders.entries());\n\n  if (rootModule) {\n    container.delete(rootModule);\n  }\n\n  return container;\n}\n","import {classOf, deepMerge, getValue, proxyDelegation, setValue} from \"@tsed/core\";\nimport {ProviderScope} from \"../domain\";\nimport type {DIResolver, TokenProvider} from \"../interfaces\";\n\nexport class DIConfiguration {\n  readonly default: Map<string, any> = new Map();\n  protected map: Map<string, any> = new Map();\n\n  [key: string]: any;\n\n  constructor(initialProps = {}) {\n    Object.entries({\n      scopes: {},\n      resolvers: [],\n      imports: [],\n      ...initialProps\n    }).forEach(([key, value]) => {\n      this.default.set(key, value);\n    });\n\n    return proxyDelegation<DIConfiguration>(this, {\n      ownKeys(target) {\n        return [...target.default.keys(), ...target.map.keys()];\n      }\n    });\n  }\n\n  get scopes(): {[key: string]: ProviderScope} {\n    return this.getRaw(\"scopes\");\n  }\n\n  set scopes(value: {[key: string]: ProviderScope}) {\n    this.setRaw(\"scopes\", value);\n  }\n\n  get resolvers(): DIResolver[] {\n    return this.getRaw(\"resolvers\");\n  }\n\n  set resolvers(resolvers: DIResolver[]) {\n    this.setRaw(\"resolvers\", resolvers);\n  }\n\n  get imports(): TokenProvider[] {\n    return this.getRaw(\"imports\");\n  }\n\n  set imports(imports: TokenProvider[]) {\n    this.setRaw(\"imports\", imports);\n  }\n\n  /**\n   *\n   * @param callbackfn\n   * @param thisArg\n   */\n  forEach(callbackfn: (value: any, index: string, map: Map<string, any>) => void, thisArg?: any) {\n    return new Set([...Array.from(this.default.keys()), ...Array.from(this.map.keys())]).forEach((key) => {\n      callbackfn(this.getRaw(key), key, this.map);\n    }, thisArg);\n  }\n\n  /**\n   *\n   * @param propertyKey\n   * @param value\n   */\n  set(propertyKey: string | Partial<TsED.Configuration>, value?: any): this {\n    if (typeof propertyKey === \"string\") {\n      this.setRaw(propertyKey, value);\n    } else {\n      Object.entries(propertyKey).forEach(([key, value]) => {\n        this[key] = value;\n      });\n    }\n\n    return this;\n  }\n\n  setRaw(propertyKey: string, value: any) {\n    setValue(this.map, propertyKey, value);\n\n    return this;\n  }\n\n  /**\n   *\n   * @param propertyKey\n   * @param defaultValue\n   * @returns {undefined|any}\n   */\n  get<T = any>(propertyKey: string, defaultValue?: T): T {\n    return this.resolve(this.getRaw(propertyKey, defaultValue));\n  }\n\n  getRaw(propertyKey: string, defaultValue?: any): any {\n    const value = getValue(this.map, propertyKey);\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    return getValue(this.default, propertyKey, defaultValue);\n  }\n\n  merge(obj: Partial<TsED.Configuration>) {\n    Object.entries(obj).forEach(([key, value]) => {\n      const descriptor = Object.getOwnPropertyDescriptor(DIConfiguration.prototype, key);\n      const originalValue = this.get(key);\n      value = deepMerge(value, originalValue);\n\n      if (descriptor && ![\"default\", \"set\", \"map\", \"get\"].includes(key)) {\n        this[key] = value;\n      }\n    });\n  }\n\n  /**\n   *\n   * @param value\n   * @returns {any}\n   */\n  resolve(value: any) {\n    if (typeof value === \"object\" && value !== null) {\n      if (![Array, Object].includes(classOf(value))) {\n        return value;\n      }\n\n      return Object.entries(value).reduce(\n        (o, [k, v]) => {\n          // @ts-ignore\n          o[k] = this.resolve(v);\n\n          return o;\n        },\n        Array.isArray(value) ? [] : {}\n      );\n    }\n\n    if (typeof value === \"string\") {\n      const replacer = (match: string, key: string) => getValue(this.map, key);\n      return value\n        .replace(/\\${([\\w.]+)}/gi, replacer)\n        .replace(/<([\\w.]+)>/gi, replacer)\n        .replace(/{{([\\w.]+)}}/gi, replacer);\n    }\n\n    return value;\n  }\n\n  build() {\n    this.forEach((value, key) => this.map.set(key, this.resolve(value)));\n\n    this.set = this.setRaw;\n    this.get = this.getRaw = (propertyKey: string, defaultValue?: any) => getValue(this.map, propertyKey, defaultValue);\n  }\n}\n","import {\n  ancestorsOf,\n  classOf,\n  deepClone,\n  deepMerge,\n  getClassOrSymbol,\n  isFunction,\n  isInheritedFrom,\n  isPromise,\n  Metadata,\n  nameOf,\n  prototypeOf,\n  Store\n} from \"@tsed/core\";\nimport {DI_PARAM_OPTIONS, INJECTABLE_PROP} from \"../constants\";\nimport {Configuration} from \"../decorators/configuration\";\nimport {Injectable} from \"../decorators/injectable\";\nimport {DIContext, InjectablePropertyType, ProviderScope} from \"../domain\";\nimport {Container} from \"../domain/Container\";\nimport {LocalsContainer} from \"../domain/LocalsContainer\";\nimport {Provider} from \"../domain/Provider\";\nimport {InjectionError} from \"../errors/InjectionError\";\nimport {UndefinedTokenError} from \"../errors/UndefinedTokenError\";\nimport {\n  DILogger,\n  InjectableProperties,\n  InjectablePropertyService,\n  InjectablePropertyValue,\n  InterceptorContext,\n  InterceptorMethods,\n  InvokeOptions,\n  IProvider,\n  TokenProvider\n} from \"../interfaces\";\nimport {GlobalProviders} from \"../registries/GlobalProviders\";\nimport {createContainer} from \"../utils/createContainer\";\nimport {DIConfiguration} from \"./DIConfiguration\";\n\ninterface InvokeSettings {\n  token: TokenProvider;\n  parent?: TokenProvider;\n  scope: ProviderScope;\n  isBindable: boolean;\n  deps: TokenProvider[];\n  imports: TokenProvider[];\n  provider: Provider<any>;\n\n  construct(deps: TokenProvider[]): any;\n}\n\n/**\n * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.\n *\n * ### Example:\n *\n * ```typescript\n * import {InjectorService} from \"@tsed/di\";\n *\n * // Import the services (all services are decorated with @Service()\";\n * import MyService1 from \"./services/service1\";\n * import MyService2 from \"./services/service2\";\n * import MyService3 from \"./services/service3\";\n *\n * // When all services is imported you can load InjectorService.\n * const injector = new InjectorService()\n *\n * await injector.load();\n *\n * const myService1 = injector.get<MyService1>(MyServcice1);\n * ```\n */\n@Injectable({\n  scope: ProviderScope.SINGLETON,\n  global: true\n})\nexport class InjectorService extends Container {\n  public settings: TsED.Configuration & DIConfiguration = new DIConfiguration() as any;\n  public logger: DILogger = console;\n  private resolvedConfiguration: boolean = false;\n\n  constructor() {\n    super();\n    const provider = this.addProvider(InjectorService).getProvider(InjectorService)!;\n    provider.instance = this;\n  }\n\n  get resolvers() {\n    return this.settings.resolvers!;\n  }\n\n  get scopes() {\n    return this.settings.scopes || {};\n  }\n\n  /**\n   * Retrieve default scope for a given provider.\n   * @param provider\n   */\n  public scopeOf(provider: Provider) {\n    return provider.scope || this.scopes[provider.type] || ProviderScope.SINGLETON;\n  }\n\n  /**\n   * Clone a provider from GlobalProviders and the given token. forkProvider method build automatically the provider if the instance parameter ins't given.\n   * @param token\n   * @param settings\n   */\n  public forkProvider(token: TokenProvider, settings: Partial<IProvider<any>> = {}): Provider {\n    if (!this.hasProvider(token)) {\n      this.addProvider(token);\n    }\n\n    const provider = this.getProvider(token)!;\n\n    Object.assign(provider, settings);\n\n    provider.instance = this.invoke(token);\n\n    return provider;\n  }\n\n  /**\n   * Return a list of instance build by the injector.\n   */\n  public toArray(): any[] {\n    return super.toArray().map((provider) => provider.instance);\n  }\n\n  /**\n   * Get a service or factory already constructed from his symbol or class.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/di\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *      constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.get<MyService>(MyService);\n   *      }\n   * }\n   * ```\n   *\n   * @param token The class or symbol registered in InjectorService.\n   * @param options\n   * @returns {boolean}\n   */\n  get<T = any>(token: TokenProvider, options: any = {}): T | undefined {\n    const instance = super.get(getClassOrSymbol(token))?.instance;\n\n    if (instance !== undefined) {\n      return instance;\n    }\n\n    if (!this.hasProvider(token)) {\n      for (const resolver of this.resolvers) {\n        const result = resolver.get(token, options);\n\n        if (result !== undefined) {\n          return result;\n        }\n      }\n    }\n  }\n\n  /**\n   * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n   * @returns {boolean}\n   * @param token\n   */\n  has(token: TokenProvider): boolean {\n    return super.has(getClassOrSymbol(token)) && this.get(token) !== undefined;\n  }\n\n  /**\n   * Invoke the class and inject all services that required by the class constructor.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/di\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *     constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.invoke<MyService>(MyService);\n   *      }\n   *  }\n   * ```\n   *\n   * @param token The injectable class to invoke. Class parameters are injected according constructor signature.\n   * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   * @param options\n   * @returns {T} The class constructed.\n   */\n  public invoke<T>(\n    token: TokenProvider,\n    locals: Map<TokenProvider, any> = new LocalsContainer(),\n    options: Partial<InvokeOptions<T>> = {}\n  ): T {\n    const provider = this.ensureProvider(token);\n    let instance: any;\n\n    !locals.has(Configuration) && locals.set(Configuration, this.settings);\n\n    if (locals.has(token)) {\n      return locals.get(token);\n    }\n\n    if (token === DI_PARAM_OPTIONS) {\n      return {} as T;\n    }\n\n    if (!provider || options.rebuild) {\n      instance = this.resolve(token, locals, options);\n      this.hasProvider(token) && (this.getProvider(token)!.instance = instance);\n\n      return instance;\n    }\n\n    switch (this.scopeOf(provider)) {\n      case ProviderScope.SINGLETON:\n        if (!this.has(token)) {\n          provider.instance = this.resolve(token, locals, options);\n\n          if (provider.isAsync()) {\n            provider.instance.then((instance: any) => {\n              provider.instance = instance;\n            });\n          }\n        }\n\n        instance = this.get<T>(token)!;\n        break;\n\n      case ProviderScope.REQUEST:\n        instance = this.resolve(token, locals, options);\n        locals.set(token, instance);\n        break;\n\n      case ProviderScope.INSTANCE:\n        instance = this.resolve(provider.provide, locals, options);\n        break;\n    }\n\n    return instance;\n  }\n\n  /**\n   * Build only providers which are asynchronous.\n   */\n  async loadAsync(locals: LocalsContainer<any> = new LocalsContainer()) {\n    for (const [, provider] of this) {\n      if (!locals.has(provider.token)) {\n        if (provider.isAsync()) {\n          await this.invoke(provider.token, locals);\n        }\n\n        if (provider.instance) {\n          locals.set(provider.token, provider.instance);\n        }\n      }\n    }\n\n    return locals;\n  }\n\n  loadSync(locals: LocalsContainer<any> = new LocalsContainer()) {\n    for (const [, provider] of this) {\n      if (!locals.has(provider.token) && this.scopeOf(provider) === ProviderScope.SINGLETON) {\n        this.invoke(provider.token, locals);\n      }\n\n      if (provider.instance !== undefined) {\n        locals.set(provider.token, provider.instance);\n      }\n    }\n\n    return locals;\n  }\n\n  /**\n   * Boostrap injector from container and resolve configuration.\n   *\n   * @param container\n   */\n  bootstrap(container: Container = createContainer()) {\n    // Clone all providers in the container\n    this.addProviders(container);\n\n    // Resolve all configuration\n    this.resolveConfiguration();\n\n    return this;\n  }\n\n  /**\n   * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.\n   *\n   * @param container\n   * @param rootModule\n   */\n  async load(container: Container = createContainer(), rootModule?: TokenProvider): Promise<LocalsContainer<any>> {\n    this.bootstrap(container);\n\n    // build async and sync provider\n    let locals = await this.loadAsync();\n\n    if (rootModule) {\n      await this.invoke(rootModule);\n    }\n\n    // load sync provider\n    locals = this.loadSync(locals);\n\n    await locals.emit(\"$onInit\");\n\n    return locals;\n  }\n\n  /**\n   * Load all configurations registered on providers\n   */\n  resolveConfiguration() {\n    if (this.resolvedConfiguration) {\n      return;\n    }\n    const mergedConfiguration = new Map();\n\n    super.forEach((provider) => {\n      if (provider.configuration) {\n        Object.entries(provider.configuration).forEach(([key, value]) => {\n          value = mergedConfiguration.has(key) ? deepMerge(mergedConfiguration.get(key), value) : deepClone(value);\n          mergedConfiguration.set(key, value);\n        });\n      }\n      if (provider.resolvers) {\n        this.resolvers.push(...provider.resolvers);\n      }\n    });\n\n    mergedConfiguration.forEach((value, key) => {\n      this.settings[key] = deepMerge(value, this.settings[key]);\n    });\n\n    this.settings.build();\n\n    this.resolvedConfiguration = true;\n  }\n\n  /**\n   *\n   * @param instance\n   * @param locals\n   * @param options\n   */\n  public bindInjectableProperties(instance: any, locals: Map<TokenProvider, any>, options: Partial<InvokeOptions>) {\n    const properties: InjectableProperties = ancestorsOf(classOf(instance)).reduce((properties: any, target: any) => {\n      const store = Store.from(target);\n\n      return {\n        ...properties,\n        ...(store.get(INJECTABLE_PROP) || {})\n      };\n    }, {});\n\n    Object.values(properties).forEach((definition) => {\n      switch (definition.bindingType) {\n        case InjectablePropertyType.METHOD:\n          this.bindMethod(instance, definition);\n          break;\n        case InjectablePropertyType.PROPERTY:\n          this.bindProperty(instance, definition, locals, options);\n          break;\n        case InjectablePropertyType.CONSTANT:\n          this.bindConstant(instance, definition);\n          break;\n        case InjectablePropertyType.VALUE:\n          this.bindValue(instance, definition);\n          break;\n        case InjectablePropertyType.INTERCEPTOR:\n          this.bindInterceptor(instance, definition);\n          break;\n      }\n    });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   */\n  public bindMethod(instance: any, {propertyKey}: InjectablePropertyService) {\n    const target = classOf(instance);\n    const originalMethod = instance[propertyKey];\n    const deps = Metadata.getParamTypes(prototypeOf(target), propertyKey);\n\n    instance[propertyKey] = () => {\n      const services = deps.map((dependency: any) => this.get(dependency));\n\n      return originalMethod.call(instance, ...services);\n    };\n  }\n\n  /**\n   * Create an injectable property.\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   * @param onGet\n   * @param options\n   * @param locals\n   * @param invokeOptions\n   */\n  public bindProperty(\n    instance: any,\n    {propertyKey, useType, onGet = (f: any) => f, options}: InjectablePropertyService,\n    locals: Map<TokenProvider, any>,\n    invokeOptions: Partial<InvokeOptions>\n  ) {\n    invokeOptions = {...invokeOptions};\n    locals.set(DI_PARAM_OPTIONS, {...options});\n\n    let bean: any = this.invoke(useType, locals, invokeOptions);\n\n    locals.delete(DI_PARAM_OPTIONS);\n\n    if (isPromise(bean)) {\n      bean.then((result: any) => {\n        bean = result;\n      });\n    }\n\n    Object.defineProperty(instance, propertyKey, {\n      get: () => onGet(bean)\n    });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  public bindValue(instance: any, {propertyKey, expression, defaultValue}: InjectablePropertyValue) {\n    const descriptor = {\n      get: () => this.settings.get(expression) || defaultValue,\n      set: (value: any) => this.settings.set(expression, value),\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  public bindConstant(instance: any, {propertyKey, expression, defaultValue}: InjectablePropertyValue): PropertyDescriptor {\n    const clone = (o: any) => {\n      if (o) {\n        return Object.freeze(deepClone(o));\n      }\n\n      return defaultValue;\n    };\n\n    const descriptor = {\n      get: () => clone(this.settings.get(expression)),\n\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n\n    return descriptor;\n  }\n\n  /**\n   *\n   * @param instance\n   * @param propertyKey\n   * @param useType\n   * @param options\n   */\n  public bindInterceptor(instance: any, {propertyKey, useType, options}: InjectablePropertyService) {\n    const target = classOf(instance);\n    const originalMethod = instance[propertyKey];\n\n    instance[propertyKey] = (...args: any[]) => {\n      const next = (err?: Error) => {\n        if (!err) {\n          return originalMethod.apply(instance, args);\n        }\n\n        throw err;\n      };\n\n      const context: InterceptorContext<any> = {\n        target,\n        propertyKey,\n        args,\n        options,\n        next\n      };\n\n      const interceptor = this.get<InterceptorMethods>(useType)!;\n\n      return interceptor.intercept!(\n        {\n          ...context,\n          options\n        },\n        next\n      );\n    };\n  }\n\n  /**\n   * Allow handler hack for AsyncHookContext plugin.\n   * @param ctx\n   * @param cb\n   * @protected\n   */\n  runInContext(ctx: DIContext, cb: any) {\n    return cb();\n  }\n\n  protected ensureProvider(token: TokenProvider): Provider | undefined {\n    if (!this.hasProvider(token) && GlobalProviders.has(token)) {\n      this.addProvider(token);\n    }\n\n    return this.getProvider(token)!;\n  }\n\n  /**\n   * Invoke a class method and inject service.\n   *\n   * #### IInjectableMethod options\n   *\n   * * **target**: Optional. The class instance.\n   * * **methodName**: `string` Optional. The method name.\n   * * **designParamTypes**: `any[]` Optional. List of injectable types.\n   * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   *\n   * #### Example\n   *\n   * @param target\n   * @param locals\n   * @param options\n   * @private\n   */\n  private resolve<T>(target: TokenProvider, locals: Map<TokenProvider, any>, options: Partial<InvokeOptions<T>> = {}): Promise<T> {\n    const {token, deps, construct, isBindable, imports, provider} = this.mapInvokeOptions(target, locals, options);\n\n    if (provider) {\n      GlobalProviders.onInvoke(provider, locals, deps);\n    }\n\n    let instance: any;\n    let currentDependency: any = false;\n\n    try {\n      const invokeDependency = (parent?: any) => (token: any, index: number): any => {\n        currentDependency = {token, index, deps};\n\n        if (token !== DI_PARAM_OPTIONS) {\n          const options = provider?.store?.get(`${DI_PARAM_OPTIONS}:${index}`);\n\n          locals.set(DI_PARAM_OPTIONS, options || {});\n        }\n\n        return isInheritedFrom(token, Provider, 1) ? provider : this.invoke(token, locals, {parent});\n      };\n\n      // Invoke manually imported providers\n      imports.forEach(invokeDependency());\n\n      // Inject dependencies\n      const services = deps.map(invokeDependency(token));\n\n      currentDependency = false;\n\n      instance = construct(services);\n    } catch (error) {\n      InjectionError.throwInjectorError(token, currentDependency, error);\n    }\n\n    if (instance === undefined) {\n      throw new InjectionError(\n        token,\n        `Unable to create new instance from undefined value. Check your provider declaration for ${nameOf(token)}`\n      );\n    }\n\n    if (instance && isBindable) {\n      this.bindInjectableProperties(instance, locals, options);\n    }\n\n    return instance;\n  }\n\n  /**\n   * Create options to invoke a provider or class.\n   * @param token\n   * @param locals\n   * @param options\n   */\n  private mapInvokeOptions(token: TokenProvider, locals: Map<TokenProvider, any>, options: Partial<InvokeOptions<any>>): InvokeSettings {\n    let imports: TokenProvider[] | undefined = options.imports;\n    let deps: TokenProvider[] | undefined = options.deps;\n    let scope = options.scope;\n    let construct;\n    let isBindable = false;\n\n    if (!token) {\n      throw new UndefinedTokenError();\n    }\n\n    let provider: Provider;\n\n    if (!this.hasProvider(token)) {\n      provider = new Provider(token);\n\n      this.resolvers.forEach((resolver) => {\n        const result = resolver.get(token, locals.get(DI_PARAM_OPTIONS));\n\n        if (result !== undefined) {\n          provider.useFactory = () => result;\n        }\n      });\n    } else {\n      provider = this.getProvider(token)!;\n    }\n\n    scope = scope || this.scopeOf(provider);\n    deps = deps || provider.deps;\n    imports = imports || provider.imports;\n\n    if (provider.useValue !== undefined) {\n      construct = () => (isFunction(provider.useValue) ? provider.useValue() : provider.useValue);\n    } else if (provider.useFactory) {\n      construct = (deps: TokenProvider[]) => provider.useFactory(...deps);\n    } else if (provider.useAsyncFactory) {\n      construct = (deps: TokenProvider[]) => provider.useAsyncFactory(...deps);\n    } else {\n      // useClass\n      isBindable = true;\n      deps = deps || Metadata.getParamTypes(provider.useClass);\n      construct = (deps: TokenProvider[]) => new provider.useClass(...deps);\n    }\n\n    return {\n      token,\n      scope: scope || Store.from(token).get(\"scope\") || ProviderScope.SINGLETON,\n      deps: deps! || [],\n      imports: imports || [],\n      isBindable,\n      construct,\n      provider\n    };\n  }\n}\n","import {Logger} from \"@tsed/logger\";\nimport {registerProvider} from \"../registries/ProviderRegistry\";\nimport {InjectorService} from \"./InjectorService\";\n\nregisterProvider({\n  provide: Logger,\n  deps: [InjectorService],\n  useFactory(injector: InjectorService) {\n    return injector.logger;\n  }\n});\n","import {InjectorService} from \"../services/InjectorService\";\n\n/**\n * @ignore\n * @param injector\n */\nexport function setLoggerLevel(injector: InjectorService) {\n  const level = injector.settings.logger?.level;\n\n  if (level) {\n    injector.logger.level = level;\n  }\n}\n","import {Env, getValue} from \"@tsed/core\";\nimport {$log} from \"@tsed/logger\";\nimport {Container} from \"../domain/Container\";\nimport {LocalsContainer} from \"../domain/LocalsContainer\";\nimport {OnInit} from \"../interfaces/OnInit\";\nimport {TokenProvider} from \"../interfaces/TokenProvider\";\nimport {setLoggerLevel} from \"../utils/setLoggerLevel\";\nimport {InjectorService} from \"./InjectorService\";\n\nexport interface DITestInvokeOptions {\n  token?: TokenProvider;\n  use: any;\n}\n\n/**\n * Tool to run test with lightweight DI sandbox.\n */\nexport class DITest {\n  protected static _injector: InjectorService | null = null;\n\n  static get injector(): InjectorService {\n    if (DITest._injector) {\n      return DITest._injector!;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\n      \"PlatformTest.injector is not initialized. Use PlatformTest.create(): Promise before PlatformTest.invoke() or PlatformTest.injector.\\n\" +\n        \"Example:\\n\" +\n        \"before(async () => {\\n\" +\n        \"   await PlatformTest.create()\\n\" +\n        \"   await PlatformTest.invoke(MyService, [])\\n\" +\n        \"})\"\n    );\n  }\n\n  static set injector(injector: InjectorService) {\n    DITest._injector = injector;\n  }\n\n  static hasInjector() {\n    return !!DITest._injector;\n  }\n\n  static async create(settings: Partial<TsED.Configuration> = {}) {\n    DITest.injector = DITest.createInjector(settings);\n\n    const container = new Container();\n    DITest.injector.bootstrap(container);\n\n    await DITest.injector.load(container);\n  }\n\n  /**\n   * Create a new injector with the right default services\n   */\n  static createInjector(settings: any = {}): InjectorService {\n    const injector = new InjectorService();\n    injector.logger = $log;\n\n    // @ts-ignore\n    injector.settings.set(DITest.configure(settings));\n\n    setLoggerLevel(injector);\n\n    return injector;\n  }\n\n  /**\n   * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.\n   */\n  static async reset() {\n    if (DITest.hasInjector()) {\n      await DITest.injector.destroy();\n      DITest._injector = null;\n    }\n  }\n\n  /**\n   * Invoke a provider and return a fresh instance\n   * @param target\n   * @param providers\n   */\n  static invoke<T = any>(target: TokenProvider, providers: DITestInvokeOptions[] = []): T | Promise<T> {\n    const locals = new LocalsContainer();\n    providers.forEach((p) => {\n      locals.set(p.token, p.use);\n    });\n\n    locals.set(InjectorService, DITest.injector);\n\n    const instance: OnInit = DITest.injector.invoke(target, locals, {rebuild: true});\n\n    if (instance && instance.$onInit) {\n      // await instance.$onInit();\n      const result = instance.$onInit();\n      if (result instanceof Promise) {\n        return result.then(() => instance as any);\n      }\n    }\n\n    return instance as any;\n  }\n\n  /**\n   * Return the instance from injector registry\n   * @param target\n   * @param options\n   */\n  static get<T = any>(target: TokenProvider, options: any = {}): T {\n    return DITest.injector.get<T>(target, options)!;\n  }\n\n  protected static configure(settings: Partial<TsED.Configuration> = {}): Partial<TsED.Configuration> {\n    return {\n      ...settings,\n      env: getValue(settings, \"env\", Env.TEST),\n      logger: {\n        ...getValue(settings, \"logger\", {}),\n        level: getValue(settings, \"logger.level\", \"off\")\n      }\n    };\n  }\n}\n","import {deepMerge, Store, Type} from \"@tsed/core\";\n\nexport function getConfiguration(module: Type<any>, configuration: any = {}) {\n  const store = Store.from(module).get(\"configuration\") || {};\n\n  const config = {\n    ...store,\n    ...configuration\n  };\n\n  if (store.mount && configuration.mount) {\n    config.mount = deepMerge(store.mount, configuration.mount);\n  }\n\n  if (store.componentsScan && configuration.componentsScan) {\n    config.componentsScan = [...store.componentsScan, ...configuration.componentsScan];\n  }\n\n  return config;\n}\n"],"names":["INJECTABLE_PROP","DI_PARAMS","DI_PARAM_OPTIONS","ProviderScope","ProviderType","Provider","constructor","token","options","PROVIDER","provide","useClass","Object","assign","value","getClassOrSymbol","Store","from","_useClass","isClass","classOf","className","name","nameOf","store","scope","isAsync","SINGLETON","get","set","configuration","key","useAsyncFactory","clone","toString","useFactory","useValue","filter","Boolean","join","GlobalProviderRegistry","Map","has","metadata","merge","target","meta","createIfNotExists","keys","forEach","delete","createRegistry","type","model","defaultOptions","getRegistrySettings","onInvoke","provider","locals","deps","settings","createRegisterFn","instance","item","GlobalProviders","LocalsContainer","emit","eventName","args","handler","getListeners","alter","alterAsync","toArray","values","destroy","clear","event","reduce","listeners","concat","bind","Container","add","addProvider","hasProvider","setProvider","getProvider","getProviders","Array","_","map","addProviders","container","InjectablePropertyType","ContextLogger","logger","id","url","dateStart","Date","ignoreUrlPatterns","minimalRequestPicker","completeRequestPicker","level","maxStackSize","ignoreLog","additionalProps","l","levels","toUpperCase","ALL","info","obj","run","INFO","getData","debug","withRequest","DEBUG","warn","WARN","error","ERROR","trace","TRACE","flush","length","data","isLevelEnabled","otherLevel","isLessThanOrEqualTo","undefined","getDuration","getTime","message","reqId","time","duration","mapper","push","levelStr","toLowerCase","DIContext","injector","env","Scope","REQUEST","StoreSet","CONTROLLER","registerProvider","Error","registerFactory","registerValue","VALUE","registerController","Injectable","Service","OverrideProvider","originalProvider","Inject","symbol","onGet","propertyKey","descriptor","bindingType","decoratorTypeOf","DecoratorTypes","PARAM","PARAM_CTOR","paramTypes","Metadata","getParamTypes","setParamTypes","PROP","useType","getType","METHOD","UnsupportedDecoratorType","Constant","expression","defaultValue","CONSTANT","Value","Intercept","interceptor","INTERCEPTOR","Interceptor","Configuration","CLASS","Module","imports","resolvers","useDecorators","MODULE","injectable","Opts","index","INSTANCE","UseOpts","InjectionError","origin","isString","tokens","stack","originMessage","tokensMessage","throwInjectorError","currentDependency","printDependencyInjectionError","erroredArg","getConstructorArgNames","arg","chalk","red","signature","indexOf","drawline","repeat","UndefinedTokenError","createContainer","rootModule","entries","DIConfiguration","initialProps","scopes","default","proxyDelegation","ownKeys","getRaw","setRaw","callbackfn","thisArg","Set","setValue","resolve","getValue","getOwnPropertyDescriptor","prototype","originalValue","deepMerge","includes","o","k","v","isArray","replacer","match","replace","build","InjectorService","console","InjectorService_1","scopeOf","forkProvider","invoke","resolver","result","ensureProvider","rebuild","then","loadAsync","loadSync","bootstrap","resolveConfiguration","load","resolvedConfiguration","mergedConfiguration","deepClone","bindInjectableProperties","properties","ancestorsOf","definition","bindMethod","PROPERTY","bindProperty","bindConstant","bindValue","bindInterceptor","originalMethod","prototypeOf","services","dependency","call","f","invokeOptions","bean","isPromise","defineProperty","enumerable","configurable","freeze","next","err","apply","context","intercept","runInContext","ctx","cb","construct","isBindable","mapInvokeOptions","invokeDependency","parent","isInheritedFrom","isFunction","global","Logger","setLoggerLevel","DITest","_injector","hasInjector","create","createInjector","$log","configure","reset","providers","p","use","$onInit","Promise","Env","TEST","getConfiguration","module","config","mount","componentsScan"],"mappings":"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"}