import { getClassOrSymbol, Store, isClass, classOf, nameOf, StoreSet, decoratorTypeOf, UnsupportedDecoratorType, DecoratorTypes, Metadata, useDecorators, isString, getConstructorArgNames, proxyDelegation, setValue, getValue, deepMerge, deepClone, ancestorsOf, prototypeOf, isPromise, isInheritedFrom, isFunction, Env } from '@tsed/core';
import { levels, Logger, $log } from '@tsed/logger';
import { __decorate, __metadata } from 'tslib';
import chalk from 'chalk';

const INJECTABLE_PROP = "DI:INJECTABLE_PROP";
const DI_PARAMS = "DI:PARAMS";
const DI_PARAM_OPTIONS = "DI:PARAM:OPTIONS";

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

var ProviderScope;

(function (ProviderScope) {
  ProviderScope["SINGLETON"] = "singleton";
  ProviderScope["REQUEST"] = "request";
  ProviderScope["INSTANCE"] = "instance";
})(ProviderScope || (ProviderScope = {}));

var ProviderType;

(function (ProviderType) {
  ProviderType["VALUE"] = "value";
  ProviderType["FACTORY"] = "factory";
  ProviderType["SERVICE"] = "service";
  ProviderType["PROVIDER"] = "provider";
  ProviderType["MODULE"] = "module";
  ProviderType["CONTROLLER"] = "controller";
  ProviderType["INTERCEPTOR"] = "interceptor";
  ProviderType["MIDDLEWARE"] = "middleware";
})(ProviderType || (ProviderType = {}));

var _provide = /*#__PURE__*/_classPrivateFieldLooseKey("provide");

var _store = /*#__PURE__*/_classPrivateFieldLooseKey("store");

var _tokenStore = /*#__PURE__*/_classPrivateFieldLooseKey("tokenStore");

class Provider {
  constructor(token, options = {}) {
    Object.defineProperty(this, _provide, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _store, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _tokenStore, {
      writable: true,
      value: void 0
    });
    this.type = ProviderType.PROVIDER;
    this.provide = token;
    this.useClass = token;
    Object.assign(this, options);
  }

  get token() {
    return _classPrivateFieldLooseBase(this, _provide)[_provide];
  }

  get provide() {
    return _classPrivateFieldLooseBase(this, _provide)[_provide];
  }

  set provide(value) {
    if (value) {
      _classPrivateFieldLooseBase(this, _provide)[_provide] = getClassOrSymbol(value);
      _classPrivateFieldLooseBase(this, _tokenStore)[_tokenStore] = _classPrivateFieldLooseBase(this, _store)[_store] = Store.from(value);
    }
  }

  get useClass() {
    return this._useClass;
  }
  /**
   * Create a new store if the given value is a class. Otherwise the value is ignored.
   * @param value
   */


  set useClass(value) {
    if (isClass(value)) {
      this._useClass = classOf(value);
      _classPrivateFieldLooseBase(this, _store)[_store] = Store.from(value);
    }
  }

  get className() {
    return this.name;
  }

  get name() {
    return nameOf(this.provide);
  }

  get store() {
    return _classPrivateFieldLooseBase(this, _store)[_store];
  }
  /**
   * Get the scope of the provider.
   *
   * ::: tip Note
   * Async provider is always a SINGLETON
   * :::
   *
   * @returns {boolean}
   */


  get scope() {
    if (this.isAsync()) {
      return ProviderScope.SINGLETON;
    }

    return this.get("scope");
  }
  /**
   * Change the scope value of the provider.
   * @param scope
   */


  set scope(scope) {
    this.store.set("scope", scope);
  }

  get configuration() {
    return this.get("configuration");
  }

  set configuration(configuration) {
    this.store.set("configuration", configuration);
  }

  get(key) {
    return this.store.get(key) || _classPrivateFieldLooseBase(this, _tokenStore)[_tokenStore].get(key);
  }

  isAsync() {
    return !!this.useAsyncFactory;
  }

  clone() {
    return new (classOf(this))(_classPrivateFieldLooseBase(this, _provide)[_provide], this);
  }

  toString() {
    return ["Token", this.name, this.useClass && nameOf(this.useClass), this.useFactory && "Factory", this.useValue && "Value", this.useAsyncFactory && "AsyncFactory"].filter(Boolean).join(":");
  }

}

var _settings = /*#__PURE__*/_classPrivateFieldLooseKey("settings");

class GlobalProviderRegistry extends Map {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, _settings, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _settings)[_settings] = new Map();
  }

  /**
   * The get() method returns a specified element from a Map object.
   * @param key Required. The key of the element to return from the Map object.
   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.
   */
  get(key) {
    return super.get(getClassOrSymbol(key));
  }
  /**
   * The has() method returns a boolean indicating whether an element with the specified key exists or not.
   * @param key
   * @returns {boolean}
   */


  has(key) {
    return super.has(getClassOrSymbol(key));
  }
  /**
   * The set() method adds or updates an element with a specified key and value to a Map object.
   * @param key Required. The key of the element to add to the Map object.
   * @param metadata Required. The value of the element to add to the Map object.
   */


  set(key, metadata) {
    super.set(getClassOrSymbol(key), metadata);
    return this;
  }
  /**
   *
   * @param target
   * @param options
   */


  merge(target, options) {
    const meta = this.createIfNotExists(target, options);
    Object.keys(options).forEach(key => {
      meta[key] = options[key];
    });
    this.set(target, meta);
  }
  /**
   * The delete() method removes the specified element from a Map object.
   * @param key Required. The key of the element to remove from the Map object.
   * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.
   */


  delete(key) {
    return super.delete(getClassOrSymbol(key));
  }

  createRegistry(type, model, options = {}) {
    const defaultOptions = this.getRegistrySettings(type);
    options = Object.assign(defaultOptions, _extends({}, options, {
      model
    }));

    _classPrivateFieldLooseBase(this, _settings)[_settings].set(type, options);

    return this;
  }

  onInvoke(provider, locals, deps) {
    const settings = _classPrivateFieldLooseBase(this, _settings)[_settings].get(provider.type);

    if (settings != null && settings.onInvoke) {
      settings.onInvoke(provider, locals, deps);
    }
  }

  getRegistrySettings(target) {
    let type = "provider";

    if (typeof target === "string") {
      type = target;
    } else {
      const provider = this.get(target);

      if (provider) {
        type = provider.type;
      }
    }

    return _classPrivateFieldLooseBase(this, _settings)[_settings].get(type) || {
      model: Provider
    };
  }

  createRegisterFn(type) {
    return (provider, instance) => {
      // istanbul ignore next
      if (!provider.provide) {
        provider = {
          provide: provider
        };
      }

      provider = Object.assign({
        instance
      }, provider, {
        type
      });
      this.merge(provider.provide, provider);
    };
  }
  /**
   *
   * @param key
   * @param options
   */


  createIfNotExists(key, options) {
    const type = options.type || ProviderType.PROVIDER;

    if (!this.has(key)) {
      const {
        model = Provider
      } = _classPrivateFieldLooseBase(this, _settings)[_settings].get(type) || {};
      const item = new model(key);
      this.set(key, item);
    }

    return this.get(key);
  }

}
/**
 *
 * @type {GlobalProviders}
 */
// tslint:disable-next-line: variable-name

const GlobalProviders = new GlobalProviderRegistry();

class LocalsContainer extends Map {
  /**
   * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).
   * @param eventName The event name to emit at all services.
   * @param args List of the parameters to give to each services.
   * @returns {Promise<any[]>} A list of promises.
   */
  async emit(eventName, ...args) {
    for (const handler of this.getListeners(eventName)) {
      await handler(...args);
    }
  }
  /**
   * @param eventName
   * @param value
   * @param args
   */


  alter(eventName, value, ...args) {
    for (const handler of this.getListeners(eventName)) {
      value = handler(value, ...args);
    }

    return value;
  }
  /**
   * @param eventName
   * @param value
   * @param args
   */


  async alterAsync(eventName, value, ...args) {
    for (const handler of this.getListeners(eventName)) {
      value = handler(value, ...args);
    }

    return value;
  }

  toArray() {
    return [...this.values()];
  }

  async destroy() {
    await this.emit("$onDestroy");
    this.clear();
  }

  getListeners(event) {
    return this.toArray().reduce((listeners, instance) => {
      if (typeof instance === "object" && instance && event in instance) {
        return listeners.concat(instance[event].bind(instance));
      }

      return listeners;
    }, []);
  }

}

class Container extends LocalsContainer {
  /**
   *
   * @param token
   * @param settings
   */
  add(token, settings = {}) {
    const provider = GlobalProviders.has(token) ? GlobalProviders.get(token).clone() : new Provider(token);
    Object.assign(provider, settings);
    return super.set(token, provider);
  }
  /**
   * Add a provider to the
   * @param token
   * @param settings
   */


  addProvider(token, settings = {}) {
    return this.add(token, settings);
  }
  /**
   *
   * @param token
   */


  hasProvider(token) {
    return super.has(token);
  }
  /**
   * Add a provider to the
   * @param token
   * @param provider
   */


  setProvider(token, provider) {
    return super.set(token, provider);
  }
  /**
   * The getProvider() method returns a specified element from a Map object.
   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.
   * @param token
   */


  getProvider(token) {
    return super.get(token);
  }
  /**
   * Get all providers registered in the injector container.
   *
   * @param {ProviderType} type Filter the list by the given ProviderType.
   * @returns {[TokenProvider , Provider<any>][]}
   */


  getProviders(type) {
    return Array.from(this).filter(([_, provider]) => type ? provider.type === type : true).map(([_, provider]) => provider);
  }

  addProviders(container) {
    container.forEach(provider => {
      if (!this.hasProvider(provider.provide)) {
        this.setProvider(provider.provide, provider.clone());
      }
    });
  }

}

var InjectablePropertyType;

(function (InjectablePropertyType) {
  InjectablePropertyType["METHOD"] = "method";
  InjectablePropertyType["PROPERTY"] = "property";
  InjectablePropertyType["CONSTANT"] = "constant";
  InjectablePropertyType["VALUE"] = "value";
  InjectablePropertyType["INTERCEPTOR"] = "interceptor";
})(InjectablePropertyType || (InjectablePropertyType = {}));

var _additionalProps = /*#__PURE__*/_classPrivateFieldLooseKey("additionalProps");

var _dateStart = /*#__PURE__*/_classPrivateFieldLooseKey("dateStart");

var _ignoreLog = /*#__PURE__*/_classPrivateFieldLooseKey("ignoreLog");

var _stack = /*#__PURE__*/_classPrivateFieldLooseKey("stack");

var _level = /*#__PURE__*/_classPrivateFieldLooseKey("level");

class ContextLogger {
  constructor(logger, {
    id,
    url = "",
    dateStart = new Date(),
    ignoreUrlPatterns = [],
    minimalRequestPicker,
    completeRequestPicker,
    level = "all",
    maxStackSize = 30,
    ignoreLog,
    additionalProps
  }) {
    Object.defineProperty(this, _additionalProps, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _dateStart, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _ignoreLog, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _stack, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _level, {
      writable: true,
      value: void 0
    });
    this.logger = logger;
    _classPrivateFieldLooseBase(this, _stack)[_stack] = [];
    this.id = id;
    this.url = url;
    _classPrivateFieldLooseBase(this, _additionalProps)[_additionalProps] = additionalProps || {};
    _classPrivateFieldLooseBase(this, _dateStart)[_dateStart] = dateStart;

    _classPrivateFieldLooseBase(this, _ignoreLog)[_ignoreLog] = ignoreLog || (() => false);

    this.minimalRequestPicker = minimalRequestPicker || (l => l);

    this.completeRequestPicker = completeRequestPicker || (l => l); // @ts-ignore


    _classPrivateFieldLooseBase(this, _level)[_level] = levels()[level.toUpperCase()] || levels().ALL;
    this.maxStackSize = maxStackSize;
  }

  info(obj) {
    this.run(levels().INFO, obj, obj => this.minimalRequestPicker(this.getData(obj)));
    return this;
  }

  debug(obj, withRequest = true) {
    this.run(levels().DEBUG, obj, obj => {
      obj = this.getData(obj);
      return withRequest ? this.completeRequestPicker(obj) : obj;
    });
    return this;
  }

  warn(obj) {
    this.run(levels().WARN, obj, obj => this.completeRequestPicker(this.getData(obj)));
    return this;
  }

  error(obj) {
    this.run(levels().ERROR, obj, obj => this.completeRequestPicker(this.getData(obj)));
    return this;
  }

  trace(obj) {
    this.run(levels().TRACE, obj, obj => this.completeRequestPicker(this.getData(obj)));
    return this;
  }

  flush() {
    if (_classPrivateFieldLooseBase(this, _stack)[_stack].length) {
      _classPrivateFieldLooseBase(this, _stack)[_stack].forEach(({
        level,
        data
      }) => {
        this.logger[level](data);
      });

      _classPrivateFieldLooseBase(this, _stack)[_stack] = [];
    }
  }

  isLevelEnabled(otherLevel) {
    return _classPrivateFieldLooseBase(this, _level)[_level].isLessThanOrEqualTo(otherLevel);
  }

  destroy() {
    this.flush();
    this.logger = undefined;
    _classPrivateFieldLooseBase(this, _stack)[_stack] = undefined;
  }
  /**
   * Return the duration between the time when LogIncomingRequest has handle the request and now.
   * @returns {number}
   */


  getDuration() {
    return new Date().getTime() - _classPrivateFieldLooseBase(this, _dateStart)[_dateStart].getTime();
  }

  getData(obj) {
    if (typeof obj === "string") {
      obj = {
        message: obj
      };
    }

    return _extends({}, _classPrivateFieldLooseBase(this, _additionalProps)[_additionalProps], {
      reqId: this.id,
      time: new Date(),
      duration: this.getDuration()
    }, obj);
  }

  run(level, obj, mapper) {
    if (!this.isLevelEnabled(level)) {
      return;
    }

    if (!_classPrivateFieldLooseBase(this, _ignoreLog)[_ignoreLog](obj)) {
      _classPrivateFieldLooseBase(this, _stack)[_stack].push({
        level: level.levelStr.toLowerCase(),
        data: mapper(obj)
      });
    }

    if (this.maxStackSize < _classPrivateFieldLooseBase(this, _stack)[_stack].length) {
      this.flush();
    }
  }

}

const _excluded$1 = ["id", "injector", "logger", "ignoreLog"];

var _container = /*#__PURE__*/_classPrivateFieldLooseKey("container");

var _injector = /*#__PURE__*/_classPrivateFieldLooseKey("injector");

class DIContext extends Map {
  constructor(_ref) {
    let {
      id,
      injector,
      logger,
      ignoreLog
    } = _ref,
        options = _objectWithoutPropertiesLoose(_ref, _excluded$1);

    super();
    /**
     * Date when request have been handled by the server. @@RequestLogger@@ use this date to log request duration.
     */

    Object.defineProperty(this, _container, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _injector, {
      writable: true,
      value: void 0
    });
    this.dateStart = new Date();
    _classPrivateFieldLooseBase(this, _container)[_container] = new LocalsContainer();
    this.id = id;
    injector && (_classPrivateFieldLooseBase(this, _injector)[_injector] = injector);
    this.logger = new ContextLogger(logger, _extends({}, options, {
      dateStart: this.dateStart,
      id,
      ignoreLog
    }));
  }

  /**
   * The request container used by the Ts.ED DI. It contain all services annotated with `@Scope(ProviderScope.REQUEST)`
   */
  get container() {
    return _classPrivateFieldLooseBase(this, _container)[_container];
  }
  /**
   *
   */


  get injector() {
    return _classPrivateFieldLooseBase(this, _injector)[_injector];
  }

  get env() {
    return this.injector.settings.env;
  }

  async destroy() {
    await this.container.destroy();
    this.logger.destroy(); // @ts-ignore

    delete this.logger;
  }

  async emit(eventName, ...args) {
    var _this$injector;

    return (_this$injector = this.injector) == null ? void 0 : _this$injector.emit(eventName, ...args);
  }

}

/**
 *
 * @param {"request" | "singleton" | ProviderScope} scope
 * @returns {Function}
 * @constructor
 */

function Scope(scope = ProviderScope.REQUEST) {
  return StoreSet("scope", scope);
}

/**
 *
 */

GlobalProviders.createRegistry(ProviderType.CONTROLLER, Provider);
/**
 * Register a provider configuration.
 * @param {IProvider<any>} provider
 */

function registerProvider(provider) {
  if (!provider.provide) {
    throw new Error("Provider.provide is required");
  }

  GlobalProviders.merge(provider.provide, provider);
}
/**
 * Add a new factory in the `ProviderRegistry`.
 *
 * #### Example with symbol definition
 *
 *
 * ```typescript
 * import {registerFactory, InjectorService} from "@tsed/di";
 *
 * export interface IMyFooFactory {
 *    getFoo(): string;
 * }
 *
 * export type MyFooFactory = IMyFooFactory;
 * export const MyFooFactory = Symbol("MyFooFactory");
 *
 * registerFactory(MyFooFactory, {
 *      getFoo:  () => "test"
 * });
 *
 * // or
 *
 * registerFactory({provide: MyFooFactory, instance: {
 *      getFoo:  () => "test"
 * }});
 *
 * @Service()
 * export class OtherService {
 *      constructor(@Inject(MyFooFactory) myFooFactory: MyFooFactory){
 *          console.log(myFooFactory.getFoo()); /// "test"
 *      }
 * }
 * ```
 *
 * > Note: When you use the factory method with Symbol definition, you must use the `@Inject()`
 * decorator to retrieve your factory in another Service. Advice: By convention all factory class name will be prefixed by
 * `Factory`.
 *
 * #### Example with class
 *
 * ```typescript
 * import {InjectorService, registerFactory} from "@tsed/di";
 *
 * export class MyFooService {
 *  constructor(){}
 *      getFoo() {
 *          return "test";
 *      }
 * }
 *
 * registerFactory(MyFooService, new MyFooService());
 * // or
 * registerFactory({provider: MyFooService, instance: new MyFooService()});
 *
 * @Service()
 * export class OtherService {
 *      constructor(myFooService: MyFooService){
 *          console.log(myFooFactory.getFoo()); /// "test"
 *      }
 * }
 * ```
 * @deprecated Since 2021-05-15. Use registerProvider instead.
 */

const registerFactory = registerProvider;
/**
 * Add a new value in the `ProviderRegistry`.
 *
 * #### Example with symbol definition
 *
 *
 * ```typescript
 * import {registerValue, InjectorService} from "@tsed/di";
 *
 * const MyValue = Symbol.from("MyValue")
 *
 * registerValue({token: MyValue, useValue: "myValue"});
 *
 * @Service()
 * export class OtherService {
 *      constructor(@Inject(MyValue) myValue: string){
 *          console.log(myValue); /// "myValue"
 *      }
 * }
 * ```
 */

const registerValue = (provider, value) => {
  if (!provider.provide) {
    provider = {
      provide: provider
    };
  }

  provider = Object.assign({
    scope: ProviderScope.SINGLETON,
    useValue: value
  }, provider, {
    type: ProviderType.VALUE
  });
  GlobalProviders.merge(provider.provide, provider);
};
/**
 * Add a new controller in the `ProviderRegistry`. This controller will be built when `InjectorService` will be loaded.
 *
 * #### Example
 *
 * ```typescript
 * import {registerController, InjectorService} from "@tsed/di";
 *
 * export default class MyController {
 *     constructor(){}
 *     transform() {
 *         return "test";
 *     }
 * }
 *
 * registerController({provide: MyController});
 * // or
 * registerController(MyController);
 *
 * const injector = new InjectorService();
 * injector.load();
 *
 * const myController = injector.get<MyController>(MyController);
 * myController.getFoo(); // test
 * ```
 *
 * @param provider Provider configuration.
 */

const registerController = GlobalProviders.createRegisterFn(ProviderType.CONTROLLER);

/**
 * The decorators `@Injectable()` declare a new service can be injected in other service, controller, interceptor, etc.. on there `constructor`.
 * All classes annotated with `@Injectable()` are built one time, excepted if you change the default provider configuration.
 *
 * <<< @/docs/snippets/providers/getting-started-injectable.ts
 *
 * ::: tip
 * `@Injectable()` use the `reflect-metadata` to collect and inject the built provided to other services.
 * :::
 *
 * ### Options
 *
 * - type (@@ProviderType@@  or `string`): Kind of provider. (Default: `ProviderType.PROVIDER`)
 * - scope (@@ProviderScope@): Kind of provider. (Default: `ProviderScope.SINGLETON`)
 * - deps (`Type<any>`): List of class or provider which will be injected to the constructor (Note: This options override default metadata generated by Typescript).
 *
 * @returns {Function}
 * @decorator
 */

function Injectable(options = {}) {
  return provide => {
    registerProvider(_extends({}, options, {
      provide
    }));
  };
}

/**
 * The decorators `@Service()` declare a new service can be injected in other service or controller on there `constructor`.
 * All services annotated with `@Service()` are constructed one time.
 *
 * > `@Service()` use the `reflect-metadata` to collect and inject service on controllers or other services.
 *
 * @returns {Function}
 * @decorator
 */

function Service() {
  return Injectable();
}

/**
 * Override a provider which is already registered in ProviderRegistry.
 * @returns {Function}
 * @decorators
 * @param originalProvider
 */

function OverrideProvider(originalProvider) {
  return target => {
    GlobalProviders.get(originalProvider).useClass = target;
  };
}

/**
 * Inject a provider to another provider.
 *
 * Use this decorator to inject a custom provider on constructor parameter or property.
 *
 * ```typescript
 * @Injectable()
 * export class MyService {
 *   @Inject(CONNECTION)
 *   connection: CONNECTION;
 * }
 * ```
 *
 * @param symbol
 * @param onGet Use the given name method to inject
 * @returns {Function}
 * @decorator
 */

function Inject(symbol, onGet) {
  return (target, propertyKey, descriptor) => {
    const bindingType = decoratorTypeOf([target, propertyKey, descriptor]);

    switch (bindingType) {
      case DecoratorTypes.PARAM:
      case DecoratorTypes.PARAM_CTOR:
        if (symbol) {
          const paramTypes = Metadata.getParamTypes(target, propertyKey);
          paramTypes[descriptor] = symbol;
          Metadata.setParamTypes(target, propertyKey, paramTypes);
        }

        break;

      case DecoratorTypes.PROP:
        Store.from(target).merge(INJECTABLE_PROP, {
          [propertyKey]: {
            bindingType,
            propertyKey,
            onGet,
            useType: symbol || Metadata.getType(target, propertyKey)
          }
        });
        break;

      case DecoratorTypes.METHOD:
        Store.from(target).merge(INJECTABLE_PROP, {
          [propertyKey]: {
            bindingType,
            propertyKey
          }
        });
        return descriptor;

      default:
        throw new UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);
    }
  };
}

/**
 * Return value from Configuration.
 *
 * ## Example
 *
 * ```typescript
 * import {Env} from "@tsed/core";
 * import {Constant, Value} from "@tsed/di";
 *
 * export class MyClass {
 *
 *    @Constant("env")
 *    env: Env;
 *
 *    @Value("swagger.path")
 *    swaggerPath: string;
 *
 *    @Value("swagger.path", "defaultValue")
 *    swaggerPath: string;
 *
 *    constructor() {
 *       console.log(this.swaggerPath) // undefined. Not available on constructor
 *    }
 *
 *    $onInit() {
 *      console.log(this.swaggerPath)  // something
 *    }
 * }
 * ```
 *
 * @param {string} expression
 * @param defaultValue
 * @returns {(targetClass: any, attributeName: string) => any}
 * @decorator
 */

function Constant(expression, defaultValue) {
  return (target, propertyKey) => {
    Store.from(target).merge(INJECTABLE_PROP, {
      [propertyKey]: {
        bindingType: InjectablePropertyType.CONSTANT,
        propertyKey,
        expression,
        defaultValue
      }
    });
  };
}

/**
 * Return value from Configuration.
 *
 * ## Example
 *
 * ```typescript
 * import {Env} from "@tsed/core";
 * import {Constant, Value} from "@tsed/di";
 *
 * export class MyClass {
 *
 *    @Constant("env")
 *    env: Env;
 *
 *    @Value("swagger.path")
 *    swaggerPath: string;
 *
 *    @Value("swagger.path", "defaultValue")
 *    swaggerPath: string;
 *
 *    constructor() {
 *       console.log(this.swaggerPath) // undefined. Not available on constructor
 *    }
 *
 *    $onInit() {
 *      console.log(this.swaggerPath)  // something
 *    }
 * }
 * ```
 *
 * @param expression
 * @param defaultValue
 * @returns {(targetClass: any, attributeName: string) => any}
 * @decorator
 */

function Value(expression, defaultValue) {
  return (target, propertyKey) => {
    Store.from(target).merge(INJECTABLE_PROP, {
      [propertyKey]: {
        bindingType: InjectablePropertyType.VALUE,
        propertyKey,
        expression,
        defaultValue
      }
    });
  };
}

/**
 * Attaches interceptor to method call and executes the before and after methods
 *
 * @param interceptor
 * @param options
 * @decorator
 */

function Intercept(interceptor, options) {
  return (target, propertyKey, descriptor) => {
    Store.from(target).merge(INJECTABLE_PROP, {
      [propertyKey]: {
        bindingType: InjectablePropertyType.INTERCEPTOR,
        propertyKey,
        useType: interceptor,
        options
      }
    });
    return descriptor;
  };
}

/**
 * The decorators `@Service()` declare a new service can be injected in other service or controller on there `constructor`.
 * All services annotated with `@Service()` are constructed one time.
 *
 * > `@Service()` use the `reflect-metadata` to collect and inject service on controllers or other services.
 *
 * @returns {Function}
 * @decorator
 */

function Interceptor() {
  return Injectable({
    type: ProviderType.INTERCEPTOR
  });
}

/**
 * Get or set Configuration on a class.
 *
 * @decorator
 */

function Configuration(configuration = {}) {
  return (...args) => {
    switch (decoratorTypeOf(args)) {
      case DecoratorTypes.CLASS:
        StoreSet("configuration", configuration)(args[0]);
        break;

      default:
      case DecoratorTypes.PARAM_CTOR:
        return Inject(Configuration)(args[0], args[1], args[2]);
    }
  };
}

const _excluded = ["scopes", "imports", "resolvers", "deps", "scope"];
/**
 * Declare a new Ts.ED module
 *
 * ## Options
 * - imports: List of Provider which must be built by injector before invoking the module
 * - resolvers: List of external DI must be used to resolve unknown provider
 * - deps: List of provider must be injected to the module constructor (explicit declaration)
 *
 * @param options
 * @decorator
 */

function Module(options = {}) {
  const {
    imports,
    resolvers,
    deps
  } = options,
        configuration = _objectWithoutPropertiesLoose(options, _excluded);

  return useDecorators(Configuration(configuration), Injectable({
    type: ProviderType.MODULE,
    scope: ProviderScope.SINGLETON,
    imports,
    deps,
    injectable: false,
    resolvers
  }));
}

/**
 * Get instance options. This options depending on his invocation context.
 *
 * ```typescript
 * import {Injectable, Opts, UseOpts} from "@tsed/di";
 *
 * @Injectable()
 * class MyConfigurableService {
 *   source: string;
 *   constructor(@Opts options: any = {}) {
 *      console.log("Hello ", options.source); // log: Hello Service1 then Hello Service2
 *
 *      this.source = options.source;
 *   }
 * }
 *
 * @Injectable()
 * class MyService1 {
 *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {
 *     console.log(service.source) // log: Service1
 *   }
 * }
 *
 * @Injectable()
 * class MyService2 {
 *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {
 *     console.log(service.source) // log: Service2
 *   }
 * }
 * ```
 *
 * ::: warning
 * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.
 * :::
 *
 * @param target
 * @param propertyKey
 * @param index
 * @decorator
 */

function Opts(target, propertyKey, index) {
  Scope(ProviderScope.INSTANCE)(classOf(target));
  Inject(DI_PARAM_OPTIONS)(target, propertyKey, index);
}

/**
 * Add options to invoke the Service.
 *
 * ```typescript
 * import {Injectable, Opts, UseOpts} from "@tsed/di";
 *
 * @Injectable()
 * class MyConfigurableService {
 *   source: string;
 *   constructor(@Opts options: any = {}) {
 *      console.log("Hello ", options.source); // log: Hello Service1 then Hello Service2
 *
 *      this.source = options.source;
 *   }
 * }
 *
 * @Injectable()
 * class MyService1 {
 *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {
 *     console.log(service.source) // log: Service1
 *   }
 * }
 *
 * @Injectable()
 * class MyService2 {
 *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {
 *     console.log(service.source) // log: Service2
 *   }
 * }
 * ```
 *
 * ::: warning
 * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.
 * :::
 *
 * @returns {Function}
 * @decorator
 * @param options
 */

function UseOpts(options) {
  return (target, propertyKey, index) => {
    const bindingType = decoratorTypeOf([target, propertyKey, index]);

    switch (bindingType) {
      case DecoratorTypes.PARAM_CTOR:
        Store.from(target).merge(`${DI_PARAM_OPTIONS}:${index}`, options);
        break;

      case DecoratorTypes.PROP:
        Store.from(target).merge(INJECTABLE_PROP, {
          [propertyKey]: {
            options
          }
        });
        break;

      default:
        throw new UnsupportedDecoratorType(UseOpts, [target, propertyKey, index]);
    }
  };
}

class InjectionError extends Error {
  constructor(token, origin) {
    super(isString(origin) ? origin : "");
    this.name = "INJECTION_ERROR";
    this.tokens = [];
    this.tokens = [token];

    if (origin) {
      if (isString(origin)) {
        this.origin = {
          message: origin,
          stack: this.stack
        };
      } else {
        if (origin.tokens) {
          this.tokens = this.tokens.concat(origin.tokens);
          this.origin = origin.origin;
        } else {
          this.origin = origin;
          this.stack = origin.stack;
        }
      }
    }

    const originMessage = this.origin ? "\nOrigin: " + this.origin.message : "";
    const tokensMessage = this.tokens.map(token => nameOf(token)).join(" > ");
    this.message = `Injection failed on ${tokensMessage}${originMessage}`;
  }

  static throwInjectorError(token, currentDependency, error) {
    if (currentDependency && isClass(token)) {
      error.message = printDependencyInjectionError(token, _extends({}, currentDependency, {
        message: error.message
      }));
    }

    throw new InjectionError(token, error);
  }

}

function printDependencyInjectionError(token, options) {
  let erroredArg = "";
  const args = getConstructorArgNames(token).map((arg, index) => {
    if (options.index === index) {
      erroredArg = arg;
      arg = chalk.red(arg);
    }

    return `${arg}: ${nameOf(options.deps[index])}`;
  }).join(", ");
  const signature = nameOf(token) + "->constructor(" + args + ")";
  const indexOf = signature.indexOf(erroredArg) - 5;

  const drawline = indexOf => " ".repeat(indexOf) + chalk.red("^" + "â€¾".repeat(erroredArg.length - 1));

  return "Unable to inject dependency. " + options.message + "\n\n" + signature + "\n" + (indexOf > -1 ? drawline(indexOf) : "");
}

class UndefinedTokenError extends Error {
  constructor() {
    super("Given token is undefined. Have you enabled emitDecoratorMetadata in your tsconfig.json or decorated your class with @Injectable, @Service, ... decorator ?");
    this.name = "UNDEFINED_TOKEN_ERROR";
  }

}

function createContainer(rootModule) {
  const container = new Container(GlobalProviders.entries());

  if (rootModule) {
    container.delete(rootModule);
  }

  return container;
}

class DIConfiguration {
  constructor(initialProps = {}) {
    this.default = new Map();
    this.map = new Map();
    Object.entries(_extends({
      scopes: {},
      resolvers: [],
      imports: []
    }, initialProps)).forEach(([key, value]) => {
      this.default.set(key, value);
    });
    return proxyDelegation(this, {
      ownKeys(target) {
        return [...target.default.keys(), ...target.map.keys()];
      }

    });
  }

  get scopes() {
    return this.getRaw("scopes");
  }

  set scopes(value) {
    this.setRaw("scopes", value);
  }

  get resolvers() {
    return this.getRaw("resolvers");
  }

  set resolvers(resolvers) {
    this.setRaw("resolvers", resolvers);
  }

  get imports() {
    return this.getRaw("imports");
  }

  set imports(imports) {
    this.setRaw("imports", imports);
  }
  /**
   *
   * @param callbackfn
   * @param thisArg
   */


  forEach(callbackfn, thisArg) {
    return new Set([...Array.from(this.default.keys()), ...Array.from(this.map.keys())]).forEach(key => {
      callbackfn(this.getRaw(key), key, this.map);
    }, thisArg);
  }
  /**
   *
   * @param propertyKey
   * @param value
   */


  set(propertyKey, value) {
    if (typeof propertyKey === "string") {
      this.setRaw(propertyKey, value);
    } else {
      Object.entries(propertyKey).forEach(([key, value]) => {
        this[key] = value;
      });
    }

    return this;
  }

  setRaw(propertyKey, value) {
    setValue(this.map, propertyKey, value);
    return this;
  }
  /**
   *
   * @param propertyKey
   * @param defaultValue
   * @returns {undefined|any}
   */


  get(propertyKey, defaultValue) {
    return this.resolve(this.getRaw(propertyKey, defaultValue));
  }

  getRaw(propertyKey, defaultValue) {
    const value = getValue(this.map, propertyKey);

    if (value !== undefined) {
      return value;
    }

    return getValue(this.default, propertyKey, defaultValue);
  }

  merge(obj) {
    Object.entries(obj).forEach(([key, value]) => {
      const descriptor = Object.getOwnPropertyDescriptor(DIConfiguration.prototype, key);
      const originalValue = this.get(key);
      value = deepMerge(value, originalValue);

      if (descriptor && !["default", "set", "map", "get"].includes(key)) {
        this[key] = value;
      }
    });
  }
  /**
   *
   * @param value
   * @returns {any}
   */


  resolve(value) {
    if (typeof value === "object" && value !== null) {
      if (![Array, Object].includes(classOf(value))) {
        return value;
      }

      return Object.entries(value).reduce((o, [k, v]) => {
        // @ts-ignore
        o[k] = this.resolve(v);
        return o;
      }, Array.isArray(value) ? [] : {});
    }

    if (typeof value === "string") {
      const replacer = (match, key) => getValue(this.map, key);

      return value.replace(/\${([\w.]+)}/gi, replacer).replace(/<([\w.]+)>/gi, replacer).replace(/{{([\w.]+)}}/gi, replacer);
    }

    return value;
  }

  build() {
    this.forEach((value, key) => this.map.set(key, this.resolve(value)));
    this.set = this.setRaw;

    this.get = this.getRaw = (propertyKey, defaultValue) => getValue(this.map, propertyKey, defaultValue);
  }

}

var InjectorService_1;
/**
 * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.
 *
 * ### Example:
 *
 * ```typescript
 * import {InjectorService} from "@tsed/di";
 *
 * // Import the services (all services are decorated with @Service()";
 * import MyService1 from "./services/service1";
 * import MyService2 from "./services/service2";
 * import MyService3 from "./services/service3";
 *
 * // When all services is imported you can load InjectorService.
 * const injector = new InjectorService()
 *
 * await injector.load();
 *
 * const myService1 = injector.get<MyService1>(MyServcice1);
 * ```
 */

let InjectorService = InjectorService_1 = class InjectorService extends Container {
  constructor() {
    super();
    this.settings = new DIConfiguration();
    this.logger = console;
    this.resolvedConfiguration = false;
    const provider = this.addProvider(InjectorService_1).getProvider(InjectorService_1);
    provider.instance = this;
  }

  get resolvers() {
    return this.settings.resolvers;
  }

  get scopes() {
    return this.settings.scopes || {};
  }
  /**
   * Retrieve default scope for a given provider.
   * @param provider
   */


  scopeOf(provider) {
    return provider.scope || this.scopes[provider.type] || ProviderScope.SINGLETON;
  }
  /**
   * Clone a provider from GlobalProviders and the given token. forkProvider method build automatically the provider if the instance parameter ins't given.
   * @param token
   * @param settings
   */


  forkProvider(token, settings = {}) {
    if (!this.hasProvider(token)) {
      this.addProvider(token);
    }

    const provider = this.getProvider(token);
    Object.assign(provider, settings);
    provider.instance = this.invoke(token);
    return provider;
  }
  /**
   * Return a list of instance build by the injector.
   */


  toArray() {
    return super.toArray().map(provider => provider.instance);
  }
  /**
   * Get a service or factory already constructed from his symbol or class.
   *
   * #### Example
   *
   * ```typescript
   * import {InjectorService} from "@tsed/di";
   * import MyService from "./services";
   *
   * class OtherService {
   *      constructor(injectorService: InjectorService) {
   *          const myService = injectorService.get<MyService>(MyService);
   *      }
   * }
   * ```
   *
   * @param token The class or symbol registered in InjectorService.
   * @param options
   * @returns {boolean}
   */


  get(token, options = {}) {
    var _super$get;

    const instance = (_super$get = super.get(getClassOrSymbol(token))) == null ? void 0 : _super$get.instance;

    if (instance !== undefined) {
      return instance;
    }

    if (!this.hasProvider(token)) {
      for (const resolver of this.resolvers) {
        const result = resolver.get(token, options);

        if (result !== undefined) {
          return result;
        }
      }
    }
  }
  /**
   * The has() method returns a boolean indicating whether an element with the specified key exists or not.
   * @returns {boolean}
   * @param token
   */


  has(token) {
    return super.has(getClassOrSymbol(token)) && this.get(token) !== undefined;
  }
  /**
   * Invoke the class and inject all services that required by the class constructor.
   *
   * #### Example
   *
   * ```typescript
   * import {InjectorService} from "@tsed/di";
   * import MyService from "./services";
   *
   * class OtherService {
   *     constructor(injectorService: InjectorService) {
   *          const myService = injectorService.invoke<MyService>(MyService);
   *      }
   *  }
   * ```
   *
   * @param token The injectable class to invoke. Class parameters are injected according constructor signature.
   * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
   * @param options
   * @returns {T} The class constructed.
   */


  invoke(token, locals = new LocalsContainer(), options = {}) {
    const provider = this.ensureProvider(token);
    let instance;
    !locals.has(Configuration) && locals.set(Configuration, this.settings);

    if (locals.has(token)) {
      return locals.get(token);
    }

    if (token === DI_PARAM_OPTIONS) {
      return {};
    }

    if (!provider || options.rebuild) {
      instance = this.resolve(token, locals, options);
      this.hasProvider(token) && (this.getProvider(token).instance = instance);
      return instance;
    }

    switch (this.scopeOf(provider)) {
      case ProviderScope.SINGLETON:
        if (!this.has(token)) {
          provider.instance = this.resolve(token, locals, options);

          if (provider.isAsync()) {
            provider.instance.then(instance => {
              provider.instance = instance;
            });
          }
        }

        instance = this.get(token);
        break;

      case ProviderScope.REQUEST:
        instance = this.resolve(token, locals, options);
        locals.set(token, instance);
        break;

      case ProviderScope.INSTANCE:
        instance = this.resolve(provider.provide, locals, options);
        break;
    }

    return instance;
  }
  /**
   * Build only providers which are asynchronous.
   */


  async loadAsync(locals = new LocalsContainer()) {
    for (const [, provider] of this) {
      if (!locals.has(provider.token)) {
        if (provider.isAsync()) {
          await this.invoke(provider.token, locals);
        }

        if (provider.instance) {
          locals.set(provider.token, provider.instance);
        }
      }
    }

    return locals;
  }

  loadSync(locals = new LocalsContainer()) {
    for (const [, provider] of this) {
      if (!locals.has(provider.token) && this.scopeOf(provider) === ProviderScope.SINGLETON) {
        this.invoke(provider.token, locals);
      }

      if (provider.instance !== undefined) {
        locals.set(provider.token, provider.instance);
      }
    }

    return locals;
  }
  /**
   * Boostrap injector from container and resolve configuration.
   *
   * @param container
   */


  bootstrap(container = createContainer()) {
    // Clone all providers in the container
    this.addProviders(container); // Resolve all configuration

    this.resolveConfiguration();
    return this;
  }
  /**
   * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.
   *
   * @param container
   * @param rootModule
   */


  async load(container = createContainer(), rootModule) {
    this.bootstrap(container); // build async and sync provider

    let locals = await this.loadAsync();

    if (rootModule) {
      await this.invoke(rootModule);
    } // load sync provider


    locals = this.loadSync(locals);
    await locals.emit("$onInit");
    return locals;
  }
  /**
   * Load all configurations registered on providers
   */


  resolveConfiguration() {
    if (this.resolvedConfiguration) {
      return;
    }

    const mergedConfiguration = new Map();
    super.forEach(provider => {
      if (provider.configuration) {
        Object.entries(provider.configuration).forEach(([key, value]) => {
          value = mergedConfiguration.has(key) ? deepMerge(mergedConfiguration.get(key), value) : deepClone(value);
          mergedConfiguration.set(key, value);
        });
      }

      if (provider.resolvers) {
        this.resolvers.push(...provider.resolvers);
      }
    });
    mergedConfiguration.forEach((value, key) => {
      this.settings[key] = deepMerge(value, this.settings[key]);
    });
    this.settings.build();
    this.resolvedConfiguration = true;
  }
  /**
   *
   * @param instance
   * @param locals
   * @param options
   */


  bindInjectableProperties(instance, locals, options) {
    const properties = ancestorsOf(classOf(instance)).reduce((properties, target) => {
      const store = Store.from(target);
      return _extends({}, properties, store.get(INJECTABLE_PROP) || {});
    }, {});
    Object.values(properties).forEach(definition => {
      switch (definition.bindingType) {
        case InjectablePropertyType.METHOD:
          this.bindMethod(instance, definition);
          break;

        case InjectablePropertyType.PROPERTY:
          this.bindProperty(instance, definition, locals, options);
          break;

        case InjectablePropertyType.CONSTANT:
          this.bindConstant(instance, definition);
          break;

        case InjectablePropertyType.VALUE:
          this.bindValue(instance, definition);
          break;

        case InjectablePropertyType.INTERCEPTOR:
          this.bindInterceptor(instance, definition);
          break;
      }
    });
  }
  /**
   *
   * @param instance
   * @param {string} propertyKey
   */


  bindMethod(instance, {
    propertyKey
  }) {
    const target = classOf(instance);
    const originalMethod = instance[propertyKey];
    const deps = Metadata.getParamTypes(prototypeOf(target), propertyKey);

    instance[propertyKey] = () => {
      const services = deps.map(dependency => this.get(dependency));
      return originalMethod.call(instance, ...services);
    };
  }
  /**
   * Create an injectable property.
   *
   * @param instance
   * @param {string} propertyKey
   * @param {any} useType
   * @param onGet
   * @param options
   * @param locals
   * @param invokeOptions
   */


  bindProperty(instance, {
    propertyKey,
    useType,
    onGet = f => f,
    options
  }, locals, invokeOptions) {
    invokeOptions = _extends({}, invokeOptions);
    locals.set(DI_PARAM_OPTIONS, _extends({}, options));
    let bean = this.invoke(useType, locals, invokeOptions);
    locals.delete(DI_PARAM_OPTIONS);

    if (isPromise(bean)) {
      bean.then(result => {
        bean = result;
      });
    }

    Object.defineProperty(instance, propertyKey, {
      get: () => onGet(bean)
    });
  }
  /**
   *
   * @param instance
   * @param {string} propertyKey
   * @param {any} useType
   */


  bindValue(instance, {
    propertyKey,
    expression,
    defaultValue
  }) {
    const descriptor = {
      get: () => this.settings.get(expression) || defaultValue,
      set: value => this.settings.set(expression, value),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(instance, propertyKey, descriptor);
  }
  /**
   *
   * @param instance
   * @param {string} propertyKey
   * @param {any} useType
   */


  bindConstant(instance, {
    propertyKey,
    expression,
    defaultValue
  }) {
    const clone = o => {
      if (o) {
        return Object.freeze(deepClone(o));
      }

      return defaultValue;
    };

    const descriptor = {
      get: () => clone(this.settings.get(expression)),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(instance, propertyKey, descriptor);
    return descriptor;
  }
  /**
   *
   * @param instance
   * @param propertyKey
   * @param useType
   * @param options
   */


  bindInterceptor(instance, {
    propertyKey,
    useType,
    options
  }) {
    const target = classOf(instance);
    const originalMethod = instance[propertyKey];

    instance[propertyKey] = (...args) => {
      const next = err => {
        if (!err) {
          return originalMethod.apply(instance, args);
        }

        throw err;
      };

      const context = {
        target,
        propertyKey,
        args,
        options,
        next
      };
      const interceptor = this.get(useType);
      return interceptor.intercept(_extends({}, context, {
        options
      }), next);
    };
  }
  /**
   * Allow handler hack for AsyncHookContext plugin.
   * @param ctx
   * @param cb
   * @protected
   */


  runInContext(ctx, cb) {
    return cb();
  }

  ensureProvider(token) {
    if (!this.hasProvider(token) && GlobalProviders.has(token)) {
      this.addProvider(token);
    }

    return this.getProvider(token);
  }
  /**
   * Invoke a class method and inject service.
   *
   * #### IInjectableMethod options
   *
   * * **target**: Optional. The class instance.
   * * **methodName**: `string` Optional. The method name.
   * * **designParamTypes**: `any[]` Optional. List of injectable types.
   * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
   *
   * #### Example
   *
   * @param target
   * @param locals
   * @param options
   * @private
   */


  resolve(target, locals, options = {}) {
    const {
      token,
      deps,
      construct,
      isBindable,
      imports,
      provider
    } = this.mapInvokeOptions(target, locals, options);

    if (provider) {
      GlobalProviders.onInvoke(provider, locals, deps);
    }

    let instance;
    let currentDependency = false;

    try {
      const invokeDependency = parent => (token, index) => {
        currentDependency = {
          token,
          index,
          deps
        };

        if (token !== DI_PARAM_OPTIONS) {
          var _provider$store;

          const options = provider == null ? void 0 : (_provider$store = provider.store) == null ? void 0 : _provider$store.get(`${DI_PARAM_OPTIONS}:${index}`);
          locals.set(DI_PARAM_OPTIONS, options || {});
        }

        return isInheritedFrom(token, Provider, 1) ? provider : this.invoke(token, locals, {
          parent
        });
      }; // Invoke manually imported providers


      imports.forEach(invokeDependency()); // Inject dependencies

      const services = deps.map(invokeDependency(token));
      currentDependency = false;
      instance = construct(services);
    } catch (error) {
      InjectionError.throwInjectorError(token, currentDependency, error);
    }

    if (instance === undefined) {
      throw new InjectionError(token, `Unable to create new instance from undefined value. Check your provider declaration for ${nameOf(token)}`);
    }

    if (instance && isBindable) {
      this.bindInjectableProperties(instance, locals, options);
    }

    return instance;
  }
  /**
   * Create options to invoke a provider or class.
   * @param token
   * @param locals
   * @param options
   */


  mapInvokeOptions(token, locals, options) {
    let imports = options.imports;
    let deps = options.deps;
    let scope = options.scope;
    let construct;
    let isBindable = false;

    if (!token) {
      throw new UndefinedTokenError();
    }

    let provider;

    if (!this.hasProvider(token)) {
      provider = new Provider(token);
      this.resolvers.forEach(resolver => {
        const result = resolver.get(token, locals.get(DI_PARAM_OPTIONS));

        if (result !== undefined) {
          provider.useFactory = () => result;
        }
      });
    } else {
      provider = this.getProvider(token);
    }

    scope = scope || this.scopeOf(provider);
    deps = deps || provider.deps;
    imports = imports || provider.imports;

    if (provider.useValue !== undefined) {
      construct = () => isFunction(provider.useValue) ? provider.useValue() : provider.useValue;
    } else if (provider.useFactory) {
      construct = deps => provider.useFactory(...deps);
    } else if (provider.useAsyncFactory) {
      construct = deps => provider.useAsyncFactory(...deps);
    } else {
      // useClass
      isBindable = true;
      deps = deps || Metadata.getParamTypes(provider.useClass);

      construct = deps => new provider.useClass(...deps);
    }

    return {
      token,
      scope: scope || Store.from(token).get("scope") || ProviderScope.SINGLETON,
      deps: deps || [],
      imports: imports || [],
      isBindable,
      construct,
      provider
    };
  }

};
InjectorService = InjectorService_1 = __decorate([Injectable({
  scope: ProviderScope.SINGLETON,
  global: true
}), __metadata("design:paramtypes", [])], InjectorService);

registerProvider({
  provide: Logger,
  deps: [InjectorService],

  useFactory(injector) {
    return injector.logger;
  }

});

/**
 * @ignore
 * @param injector
 */
function setLoggerLevel(injector) {
  var _injector$settings$lo;

  const level = (_injector$settings$lo = injector.settings.logger) == null ? void 0 : _injector$settings$lo.level;

  if (level) {
    injector.logger.level = level;
  }
}

/**
 * Tool to run test with lightweight DI sandbox.
 */

class DITest {
  static get injector() {
    if (DITest._injector) {
      return DITest._injector;
    }
    /* istanbul ignore next */


    throw new Error("PlatformTest.injector is not initialized. Use PlatformTest.create(): Promise before PlatformTest.invoke() or PlatformTest.injector.\n" + "Example:\n" + "before(async () => {\n" + "   await PlatformTest.create()\n" + "   await PlatformTest.invoke(MyService, [])\n" + "})");
  }

  static set injector(injector) {
    DITest._injector = injector;
  }

  static hasInjector() {
    return !!DITest._injector;
  }

  static async create(settings = {}) {
    DITest.injector = DITest.createInjector(settings);
    const container = new Container();
    DITest.injector.bootstrap(container);
    await DITest.injector.load(container);
  }
  /**
   * Create a new injector with the right default services
   */


  static createInjector(settings = {}) {
    const injector = new InjectorService();
    injector.logger = $log; // @ts-ignore

    injector.settings.set(DITest.configure(settings));
    setLoggerLevel(injector);
    return injector;
  }
  /**
   * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.
   */


  static async reset() {
    if (DITest.hasInjector()) {
      await DITest.injector.destroy();
      DITest._injector = null;
    }
  }
  /**
   * Invoke a provider and return a fresh instance
   * @param target
   * @param providers
   */


  static invoke(target, providers = []) {
    const locals = new LocalsContainer();
    providers.forEach(p => {
      locals.set(p.token, p.use);
    });
    locals.set(InjectorService, DITest.injector);
    const instance = DITest.injector.invoke(target, locals, {
      rebuild: true
    });

    if (instance && instance.$onInit) {
      // await instance.$onInit();
      const result = instance.$onInit();

      if (result instanceof Promise) {
        return result.then(() => instance);
      }
    }

    return instance;
  }
  /**
   * Return the instance from injector registry
   * @param target
   * @param options
   */


  static get(target, options = {}) {
    return DITest.injector.get(target, options);
  }

  static configure(settings = {}) {
    return _extends({}, settings, {
      env: getValue(settings, "env", Env.TEST),
      logger: _extends({}, getValue(settings, "logger", {}), {
        level: getValue(settings, "logger.level", "off")
      })
    });
  }

}
DITest._injector = null;

function getConfiguration(module, configuration = {}) {
  const store = Store.from(module).get("configuration") || {};

  const config = _extends({}, store, configuration);

  if (store.mount && configuration.mount) {
    config.mount = deepMerge(store.mount, configuration.mount);
  }

  if (store.componentsScan && configuration.componentsScan) {
    config.componentsScan = [...store.componentsScan, ...configuration.componentsScan];
  }

  return config;
}

export { Configuration, Constant, Container, ContextLogger, DIConfiguration, DIContext, DITest, DI_PARAMS, DI_PARAM_OPTIONS, GlobalProviderRegistry, GlobalProviders, INJECTABLE_PROP, Inject, Injectable, InjectablePropertyType, InjectionError, InjectorService, Intercept, Interceptor, LocalsContainer, Module, Opts, OverrideProvider, Provider, ProviderScope, ProviderType, Scope, Service, UndefinedTokenError, UseOpts, Value, createContainer, getConfiguration, registerController, registerFactory, registerProvider, registerValue, setLoggerLevel };
//# sourceMappingURL=index.modern.js.map
